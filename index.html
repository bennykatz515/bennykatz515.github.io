<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Car World Colosseum</title>
<!-- Keep your favicon setup from earlier -->
<link rel="icon" href="/favicon.png" />

<style>
  :root {
    --safe-padding: env(safe-area-inset-top, 0) env(safe-area-inset-right, 0) env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0);
  }
  html, body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif;
    color: #fff;
    background: #000; /* fallback color while image loads */
    overscroll-behavior: none;
    touch-action: manipulation;
    user-select: none;
    height: 100svh;
    overflow: hidden;
  }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif;
    color: #fff;
    background: #000; /* fallback color while image loads */
    overscroll-behavior: none;
    touch-action: manipulation;
    user-select: none;
  }
  /* Responsive background using AVIF with WebP fallback */
  .bg {
    position: fixed; inset: 0; z-index: -1;
    /* Stretch to fully cover so the red shows everywhere */
    background-position: center; background-repeat: no-repeat; background-size: 100% 100%;
    background-image: url('RedBackdrop.webp');
  }
  @supports (background-image: image-set(url('x.avif') type('image/avif'))) {
    .bg { background-image: image-set(url('RedBackdrop.webp') type('image/webp') 1x); }
  }
  @supports (background-image: image-set(url('x.avif') type('image/avif'))) {
    .bg {
      background-image: image-set(
        url('RedBackdrop.avif') type('image/avif') 1x,
        url('RedBackdrop.webp') type('image/webp') 1x
      );
    }
  }

  /* Overlay to deter long-press/save and catch right-clicks */

  /* Layout */
  .wrap { min-height: 100svh; display: grid; grid-template-rows: auto 1fr auto; padding: 8px; }
  header { display: grid; place-items: center; padding: 8px 0; }
  main { display: grid; place-items: center; }
  footer { display: grid; place-items: center; padding: 16px 0; }

  .logo { width: min(70vw, 520px); height: auto; pointer-events: none; -webkit-user-drag: none; }
  .stage { position: relative; height: min(62svh, 620px); aspect-ratio: 430/756; width: auto; border-radius: 12px; overflow: hidden; box-shadow: none; }
  .cardArea { position: absolute; inset: 0; }
  .centerCard { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%) scaleX(1); width:auto; height:70%; image-rendering:auto; transition: transform 220ms ease-in, filter 300ms ease-in-out; filter: drop-shadow(0 6px 16px rgba(0,0,0,.45)); pointer-events:auto; cursor:pointer; }
  .centerCard.squish { transform:translate(-50%,-50%) scaleX(0.02); }
  /* Pulsing clickable glow */
  @keyframes pulseGlow {
    0% { filter: drop-shadow(0 0 0 rgba(255, 234, 0, 0.0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
    50% { filter: drop-shadow(0 0 22px rgba(255, 234, 0, .9)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
    100% { filter: drop-shadow(0 0 0 rgba(255, 234, 0, 0.0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  }
  .clickable { animation: pulseGlow 1.2s ease-in-out infinite; }

  /* Arms */
  .arm { position:absolute; opacity:0; pointer-events:none; transition: transform 600ms cubic-bezier(.22,1,.36,1), opacity 220ms ease-out, left 600ms cubic-bezier(.22,1,.36,1), top 600ms cubic-bezier(.22,1,.36,1); filter: drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  .armLeft { transform: translate(-140%, 0); }
  .armTop { transform: translate(0, -140%); }
  .armRight { transform: translate(140%, 0); }
  .arm.in { opacity:1; transform: translate(0,0); }
  .armLeft { left: 5%; top: 50%; transform: translate(-120%, -50%); }
  .armTop { left: 50%; top: 8%; transform: translate(-50%, -120%); height:36%; }
  .armRight { right: 5%; top: 50%; transform: translate(120%, -50%); }
  .arm.in { opacity:1; }
  /* Final snap positions next to body */
  
  .snapTop { left: 50%; top: 18%; transform: translate(-50%, 0); }
  .snapRight { right: 13%; top: 50%; transform: translate(0, -50%); }

  /* Champion red glow for all four */
  .championGlow { filter: drop-shadow(0 0 24px rgba(255,0,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.55)); }

  .centerCard.squish { transform:translate(-50%,-50%) scaleX(0.02); }
  .centerCard.squish { transform:translate(-50%,-50%) scaleX(0.02); }

  /* CTA text example; you can replace with your styled image later */
  .cta { text-align: center; font-weight: 700; letter-spacing: .02em; text-shadow: 0 2px 8px rgba(0,0,0,.6); }
  .cta .small { opacity: .85; font-weight: 600; }

  /* Loading gate */

  /* Prevent image dragging/selection globally */
  img { -webkit-user-drag: none; user-drag: none; }
  [data-interactive] { pointer-events: auto; }
</style>

<body>
  <div class="bg" aria-hidden="true"></div>
  <div class="wrap">
    <header>
      <img class="logo" src="logo.webp" alt="Car World Colosseum" width="900" height="522" />
    </header>

    <main>
      <div class="stage" id="stage" role="region" aria-label="Game stage">
        <div class="cardArea" id="cardArea">
          <img id="centerCard" class="centerCard" alt="Attendant" />
          <img id="armLeft" class="arm armLeft" alt="Left Arm" />
          <img id="armTop" class="arm armTop" alt="Top Arm" />
          <img id="armRight" class="arm armRight" alt="Right Arm" />
        </div>
      </div>
    </main>

    <footer>
      <div class="cta">
        <div class="small">JOIN THE WAITING LIST</div>
        <div>FOR A CHANCE TO WIN A GOLDEN ATTENDANT</div>
      </div>
    </footer>

    <div style="text-align:center; font-size:0.85rem; opacity:0.75; padding:8px 0;">
      © 2025 Car World Colosseum
    </div>
  </div>  </div>

<script>
  /* ------------------------------------------------------------
   * Preload (WebP-only) + cycle arms + flip to champion
   * ---------------------------------------------------------- */
  const manifest = [
    'RedBackdrop.webp', 'logo.webp', 'body.webp', 'champion.webp',
    // Arm images (4 classes × 3 positions)
    'fighter_left.webp','fighter_right.webp','fighter_sensitivity.webp',
    'fucker_left.webp','fucker_right.webp','fucker_sensitivity.webp',
    'fracker_left.webp','fracker_right.webp','fracker_sensitivity.webp',
    'freak_left.webp','freak_right.webp','freak_sensitivity.webp',
  ];

  const classes = ['fighter','fucker','fracker','freak'];
  const positions = ['left','sensitivity','right']; // map: left, top, right

  // Elements
  const stage = document.getElementById('stage');
  const centerCard = document.getElementById('centerCard');
  const armLeft = document.getElementById('armLeft');
  const armTop = document.getElementById('armTop');
  const armRight = document.getElementById('armRight');

  function preload(url) {
    return new Promise((resolve) => {
      if (!/\.(webp|png|jpg|jpeg|gif|svg)(\?.*)?$/i.test(url)) { resolve(); return; }
      const img = new Image();
      img.onload = img.onerror = () => resolve();
      img.src = url;
    });
  }

  async function prewarm() {
    for (const url of manifest) { await preload(url); }
  }

  function setSrc(img, name) { img.src = name; }

  function randomChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

  let busy = true;     // block until first reveal
  let locked = false;  // becomes true after champion

  (async function init() {
    await prewarm();
    // Show body, pulse glow, enable clicking
    setSrc(centerCard, 'body.webp');
    centerCard.classList.add('clickable');
    busy = false;
  })();

  // Build one cycle of 3 random arms
  function pickArms() {
    const leftClass = randomChoice(classes);
    const topClass = randomChoice(classes);
    const rightClass = randomChoice(classes);
    return {
      left: { cls: leftClass, file: `${leftClass}_left.webp` },
      top: { cls: topClass, file: `${topClass}_sensitivity.webp` },
      right: { cls: rightClass, file: `${rightClass}_right.webp` },
    };
  }

  function clearChampionGlow() {
    [centerCard, armLeft, armTop, armRight].forEach(el => el.classList.remove('championGlow'));
  }

  function applyChampionGlow() {
    [centerCard, armLeft, armTop, armRight].forEach(el => el.classList.add('championGlow'));
  }

  function armsIn(arms) {
    return new Promise(resolve => {
      // Ensure images have correct sources first
      setSrc(armLeft, arms.left.file);
      setSrc(armTop, arms.top.file);
      setSrc(armRight, arms.right.file);

      // After images load, compute targets based on body size
      const waitLoads = [armLeft, armTop, armRight].map(img => new Promise(r => {
        if (img.complete) return r();
        img.onload = () => r(); img.onerror = () => r();
      }));

      Promise.all(waitLoads).then(() => {
        const stageRect = stage.getBoundingClientRect();
        const bodyRect = centerCard.getBoundingClientRect();

        // LEFT: match body height, sit flush to body's left side
        const leftRatio = armLeft.naturalWidth / armLeft.naturalHeight || 1;
        const leftH = bodyRect.height; const leftW = leftH * leftRatio;
        armLeft.style.height = leftH + 'px'; armLeft.style.width = leftW + 'px';
        armLeft.style.top = (bodyRect.top - stageRect.top) + 'px';
        armLeft.style.left = (bodyRect.left - stageRect.left - leftW) + 'px';

        // RIGHT: match body height, flush to body's right side
        const rightRatio = armRight.naturalWidth / armRight.naturalHeight || 1;
        const rightH = bodyRect.height; const rightW = rightH * rightRatio;
        armRight.style.height = rightH + 'px'; armRight.style.width = rightW + 'px';
        armRight.style.top = (bodyRect.top - stageRect.top) + 'px';
        armRight.style.left = (bodyRect.right - stageRect.left) + 'px';

        // TOP: match body width, sit directly above
        const topRatio = armTop.naturalWidth / armTop.naturalHeight || 1;
        const topW = bodyRect.width; const topH = topW / topRatio;
        armTop.style.width = topW + 'px'; armTop.style.height = topH + 'px';
        armTop.style.left = (bodyRect.left - stageRect.left) + 'px';
        armTop.style.top = (bodyRect.top - stageRect.top - topH) + 'px';

        // Fade/slide in
        requestAnimationFrame(() => {
          armLeft.classList.add('in');
          armTop.classList.add('in');
          armRight.classList.add('in');
        });

        setTimeout(resolve, 620);
      });
    });
  }

  function armsOut() {
    // slide them outward away from body and fade
    return new Promise(resolve => {
      armLeft.classList.remove('in');
      armTop.classList.remove('in');
      armRight.classList.remove('in');
      setTimeout(() => {
        armLeft.style.opacity = '0';
        armTop.style.opacity = '0';
        armRight.style.opacity = '0';
        resolve();
      }, 260);
    });
  }

  function armsResetStyles(){
    [armLeft, armTop, armRight].forEach(el=>{
      el.removeAttribute('style');
      // keep base classes
    });
  }

  function armsOutAndReset(){
    return armsOut().then(()=>{ armsResetStyles(); });
  }

  function armsOut() {
    // fly back where they came from
    armLeft.className = 'arm armLeft in';
    armTop.className = 'arm armTop in';
    armRight.className = 'arm armRight in';

    // Move offscreen and fade a bit quicker
    requestAnimationFrame(() => {
      armLeft.classList.remove('snapLeft');
      armTop.classList.remove('snapTop');
      armRight.classList.remove('snapRight');
      armLeft.style.transitionDuration = '250ms';
      armTop.style.transitionDuration = '250ms';
      armRight.style.transitionDuration = '250ms';
      armLeft.style.opacity = '0';
      armTop.style.opacity = '0';
      armRight.style.opacity = '0';
    });

    return new Promise(resolve => setTimeout(resolve, 270));
  }

  function isChampion(arms) {
    const a = arms.left.cls;
    return a === arms.top.cls && a === arms.right.cls;
  }

  // Flip to champion once, then lock
  function flipToChampion() {
    centerCard.classList.remove('clickable');
    centerCard.style.transition = 'transform 220ms ease-in';
    centerCard.classList.add('squish');
  }

  centerCard.addEventListener('click', async () => {
    if (busy || locked) return;
    busy = true;
    clearChampionGlow();
    centerCard.classList.remove('clickable');

    // If arms are visible, remove them first
    const armsVisible = armLeft.classList.contains('in') || armTop.classList.contains('in') || armRight.classList.contains('in');
    if (armsVisible) await armsOutAndReset();

    const arms = pickArms();
    await armsIn(arms);

    if (isChampion(arms)) {
      // add red glow and flip to champion
      applyChampionGlow();
      locked = true;
      flipToChampion();
    } else {
      // re-enable pulsing glow to invite next click
      centerCard.classList.add('clickable');
      busy = false;
    }
  });

  // Complete the flip (squish -> swap -> expand)
  centerCard.addEventListener('transitionend', (e) => {
    if (e.propertyName !== 'transform') return;
    if (locked && centerCard.classList.contains('squish')) {
      setSrc(centerCard, 'champion.webp');
      centerCard.style.transition = 'transform 260ms ease-out';
      centerCard.classList.remove('squish');
    }
  });
</script>
</body>
</html>
