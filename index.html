<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Car World Colosseum</title>
<!-- Keep your favicon setup from earlier -->
<link rel="icon" href="/favicon.png" />

<style>
  :root {
    --safe-padding: env(safe-area-inset-top, 0) env(safe-area-inset-right, 0) env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0);
  }
  html, body { height: 100%; margin: 0; background: transparent; }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif;
    color: #fff;
    background: #000; /* fallback color while image loads */
    overscroll-behavior: none;
    touch-action: manipulation;
    user-select: none;
  }
  /* Responsive background using AVIF with WebP fallback */
  .bg {
    position: fixed; inset: 0; z-index: -1;
    /* Solid red fallback behind the image; 'cover' to avoid odd stretching */
    background-color: #7b0000;
    background-position: center; background-repeat: no-repeat; background-size: cover;
    background-image: url('RedBackdrop.webp?v=1');
  }
  @supports (background-image: image-set(url('x.avif') type('image/avif'))) {
    .bg { background-image: image-set(url('RedBackdrop.webp') type('image/webp') 1x); }
  }
  @supports (background-image: image-set(url('x.avif') type('image/avif'))) {
    .bg {
      background-image: image-set(
        url('RedBackdrop.avif') type('image/avif') 1x,
        url('RedBackdrop.webp') type('image/webp') 1x
      );
    }
  }

  /* Overlay to deter long-press/save and catch right-clicks */

  /* Layout */
  .wrap { min-height: 100svh; display: grid; grid-template-rows: auto 1fr auto; padding: 8px; }
  header { display: grid; place-items: center; padding: 8px 0; }
  main { display: grid; place-items: center; }
  footer { display: grid; place-items: center; padding: 16px 0; }

  .logo { width: min(70vw, 520px); height: auto; pointer-events: none; -webkit-user-drag: none; }
  .stage { position: relative; width: min(86vw, 420px); height: min(70svh, 620px); border-radius: 12px; overflow: visible; box-shadow: none; margin-top: 6px; display:grid; place-items:center; }
  .cardArea { position: absolute; inset: 0; }
  .card { position:absolute; image-rendering:auto; filter: drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  .centerCard { transition: transform 220ms ease-in, filter 300ms ease-in-out; cursor:pointer; }
  .centerCard.squish { transform-origin:center; transform: scaleX(0.02); }
  /* Pulsing clickable glow */
  @keyframes pulseGlow { 0% { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); } 50% { filter: drop-shadow(0 0 22px rgba(255,234,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); } 100% { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); } }
  .clickable { animation: pulseGlow 1.2s ease-in-out infinite; }

  /* Arms */
  .arm { opacity:0; pointer-events:none; transition: left 2000ms cubic-bezier(.16,1,.3,1), top 2000ms cubic-bezier(.16,1,.3,1), transform 2000ms cubic-bezier(.16,1,.3,1), opacity 500ms ease-out; }
  .championGlow { filter: drop-shadow(0 0 24px rgba(255,0,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.55)); }

  /* Champion perimeter frame */
  .champFrame { position:absolute; pointer-events:none; border: 6px solid rgba(255,0,0,.65); border-radius: 10px; opacity:0; box-shadow: 0 0 0 rgba(255,0,0,0); transition: opacity 280ms ease; }
  @keyframes pulseRed { 0% { box-shadow: 0 0 0 rgba(255,0,0,0.15); } 50% { box-shadow: 0 0 28px rgba(255,0,0,.95); } 100% { box-shadow: 0 0 0 rgba(255,0,0,0.15); } }
  .champFrame.visible { opacity:1; }
  .champFrame.pulse { animation: pulseRed 1.8s ease-in-out 1; }
  @keyframes pulseRed { 0% { box-shadow: 0 0 0 rgba(255,0,0,0.2); } 50% { box-shadow: 0 0 24px rgba(255,0,0,.95); } 100% { box-shadow: 0 0 0 rgba(255,0,0,0.2); } }
  .champFrame.visible { opacity:1; }
  .champFrame.pulse { animation: pulseRed 700ms ease-in-out 1; }
  .centerCard { transition: transform 220ms ease-in, filter 300ms ease-in-out; cursor:pointer; }
  .centerCard.squish { transform-origin:center; transform: scaleX(0.02); }
  /* Pulsing clickable glow */
  @keyframes pulseGlow { 0% { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); } 50% { filter: drop-shadow(0 0 22px rgba(255,234,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); } 100% { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); } }
  .clickable { animation: pulseGlow 1.2s ease-in-out infinite; }

  /* Arms */
  .arm { opacity:0; pointer-events:none; transition: left 1400ms cubic-bezier(.22,1,.36,1), top 1400ms cubic-bezier(.22,1,.36,1), opacity 380ms ease-out; }
  .championGlow { filter: drop-shadow(0 0 24px rgba(255,0,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.55)); }
  .centerCard.squish { transform:translate(-50%,-50%) scaleX(0.02); }
  /* Pulsing clickable glow */
  @keyframes pulseGlow {
    0% { filter: drop-shadow(0 0 0 rgba(255, 234, 0, 0.0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
    50% { filter: drop-shadow(0 0 22px rgba(255, 234, 0, .9)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
    100% { filter: drop-shadow(0 0 0 rgba(255, 234, 0, 0.0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  }
  .clickable { animation: pulseGlow 1.2s ease-in-out infinite; }

  /* Arms */
  .arm { position:absolute; opacity:0; pointer-events:none; transition: transform 1200ms cubic-bezier(.22,1,.36,1), opacity 320ms ease-out, left 1200ms cubic-bezier(.22,1,.36,1), top 1200ms cubic-bezier(.22,1,.36,1); filter: drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  .armLeft { transform: translate(-160%, 0); }
  .armTop { transform: translate(0, -160%); }
  .armRight { transform: translate(160%, 0); }
  .arm.in { opacity:1; transform: translate(0,0); }
  .armLeft { transform: translate(-140%, 0); }
  .armTop { transform: translate(0, -140%); }
  .armRight { transform: translate(140%, 0); }
  .arm.in { opacity:1; transform: translate(0,0); }
  .armLeft { left: 5%; top: 50%; transform: translate(-120%, -50%); }
  .armTop { left: 50%; top: 8%; transform: translate(-50%, -120%); height:36%; }
  .armRight { right: 5%; top: 50%; transform: translate(120%, -50%); }
  .arm.in { opacity:1; }
  /* Final snap positions next to body */
  
  .snapTop { left: 50%; top: 18%; transform: translate(-50%, 0); }
  .snapRight { right: 13%; top: 50%; transform: translate(0, -50%); }

  /* Champion red glow for all four */
  .championGlow { filter: drop-shadow(0 0 24px rgba(255,0,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.55)); }

  .centerCard.squish { transform:translate(-50%,-50%) scaleX(0.02); }
  .centerCard.squish { transform:translate(-50%,-50%) scaleX(0.02); }

  /* CTA text example; you can replace with your styled image later */
  .cta { text-align: center; font-weight: 700; letter-spacing: .02em; text-shadow: 0 2px 8px rgba(0,0,0,.6); }
  .cta .small { opacity: .85; font-weight: 600; }

  /* Loading gate */

  /* Prevent image dragging/selection globally */
  img { -webkit-user-drag: none; user-drag: none; }
  [data-interactive] { pointer-events: auto; }
</style>

<body>
  <div class="bg" aria-hidden="true"></div>
  <div class="wrap">
    <header>
      <img class="logo" src="logo.webp" alt="Car World Colosseum" width="900" height="522" />
    </header>

    <main>
      <div class="stage" id="stage" role="region" aria-label="Game stage">
        <div class="cardArea" id="cardArea">
          <img id="centerCard" class="card centerCard" alt="Attendant" />
          <img id="armLeft" class="card arm armLeft" alt="Left Arm" />
          <img id="armTop" class="card arm armTop" alt="Top Arm" />
          <img id="armRight" class="card arm armRight" alt="Right Arm" />
          <div id="champFrame" class="champFrame" aria-hidden="true"></div>
        </div>
      </div>
    </main>

    <footer>
      <div class="cta">
        <div class="small">JOIN THE WAITING LIST</div>
        <div>FOR A CHANCE TO WIN A GOLDEN ATTENDANT</div>
      </div>
    </footer>

    <div style="text-align:center; font-size:0.85rem; opacity:0.75; padding:8px 0;">
      Â© 2025 Car World Colosseum
    </div>
  </div>  </div>

<script>
  /* ------------------------------------------------------------
   * Equal-size cards by aspect, slower entrances, separated exit/enter, champion perimeter
   * ---------------------------------------------------------- */
  const manifest = [
    'RedBackdrop.webp', 'logo.webp', 'body.webp', 'champion.webp',
    'fighter_left.webp','fighter_right.webp','fighter_sensitivity.webp',
    'fucker_left.webp','fucker_right.webp','fucker_sensitivity.webp',
    'fracker_left.webp','fracker_right.webp','fracker_sensitivity.webp',
    'freak_left.webp','freak_right.webp','freak_sensitivity.webp',
  ];

  const classes = ['fighter','fucker','fracker','freak'];

  // Elements
  const stage = document.getElementById('stage');
  const centerCard = document.getElementById('centerCard');
  const armLeft = document.getElementById('armLeft');
  const armTop = document.getElementById('armTop');
  const armRight = document.getElementById('armRight');
  const champFrame = document.getElementById('champFrame');

  function preload(url) {
    return new Promise((resolve) => {
      if (!/\.(webp|png|jpg|jpeg|gif|svg)(\?.*)?$/i.test(url)) { resolve(); return; }
      const img = new Image(); img.onload = img.onerror = () => resolve(); img.src = url;
    });
  }
  async function prewarm(){ for(const u of manifest) await preload(u); }
  function setSrc(img, file){ img.src = file; }
  function rc(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // Natural aspect ratio of the body art
  const bodyProbe = new Image(); bodyProbe.src = 'body.webp';
  let BODY_AR = 375/525; // fallback if not loaded yet
  bodyProbe.onload = () => { if(bodyProbe.naturalWidth) BODY_AR = bodyProbe.naturalWidth / bodyProbe.naturalHeight; }; bodyProbe.src = 'body.webp';
  let BODY_AR = 375/525; // fallback if not loaded yet
  bodyProbe.onload = () => { if(bodyProbe.naturalWidth) BODY_AR = bodyProbe.naturalWidth / bodyProbe.naturalHeight; };

  // Layout state
  let layout = null; // {w,h,size, body, top, left, right, off}
  const PAD = 8; // keep away from phone edges

  function computeLayout(){
    const r = stage.getBoundingClientRect();
    const pad = 10; // inner safety margin
    // Card must fit in a 2x2 block centered in stage, respecting aspect ratio
    const maxW = (r.width - pad*2) / 2;
    const maxH = (r.height - pad*2) / 2;
    const fromHtoW = maxH * BODY_AR;
    const cardW = Math.min(maxW, fromHtoW);
    const cardH = cardW / BODY_AR;

    // Center the 2x2 block in the stage
    const blockW = cardW * 2;
    const blockH = cardH * 2;
    const blockLeft = Math.round(r.left + (r.width - blockW)/2);
    const blockTop  = Math.round(r.top  + (r.height - blockH)/2);

    // Body is bottom-right of the 2x2 block's center (i.e., center of stage)
    const bodyX = blockLeft + cardW; // center column
    const bodyY = blockTop  + cardH; // center row (bottom cell)

    layout = {
      w: cardW, h: cardH,
      body: { left: bodyX, top: bodyY },
      top:  { left: bodyX,      top: bodyY - cardH },
      left: { left: bodyX - cardW, top: bodyY },
      right:{ left: bodyX + cardW, top: bodyY },
      off: {
        left:  { left: bodyX - cardW - r.width, top: bodyY },
        top:   { left: bodyX, top: bodyY - cardH - r.height },
        right: { left: bodyX + cardW + r.width, top: bodyY },
      },
      frame: { left: blockLeft, top: blockTop, width: blockW, height: blockH }
    };
  },
      top:  { left: bodyX, top: bodyY - cardH },
      left: { left: bodyX - cardW, top: bodyY },
      right:{ left: bodyX + cardW, top: bodyY },
      off: {
        left: { left: bodyX - cardW - r.width, top: bodyY },
        top:  { left: bodyX, top: bodyY - cardH - r.height },
        right:{ left: bodyX + cardW + r.width, top: bodyY },
      },
      frame: { left: bodyX - cardW, top: bodyY - cardH, width: cardW*2, height: cardH*2 }
    };
  }

  function place(el, rect){
    const s = stage.getBoundingClientRect();
    el.style.width = layout.w + 'px';
    el.style.height = layout.h + 'px';
    el.style.left = (rect.left - s.left) + 'px';
    el.style.top  = (rect.top - s.top) + 'px';
  }
  function placeCenter(){ place(centerCard, layout.body); }
  function placeFrame(){ const s = stage.getBoundingClientRect(); champFrame.style.left=(layout.frame.left - s.left)+ 'px'; champFrame.style.top=(layout.frame.top - s.top)+'px'; champFrame.style.width=layout.frame.width+'px'; champFrame.style.height=layout.frame.height+'px'; }

  let state = 'idle'; // 'idle' (no arms), 'armsIn', 'armsOut'
  let locked = false;

  (async function init(){
    await prewarm();
    computeLayout();
    setSrc(centerCard, 'body.webp');
    placeCenter();
    centerCard.classList.add('clickable');
    state = 'idle';
  })();

  window.addEventListener('resize', ()=>{
    computeLayout(); placeCenter();
    if(state==='armsIn'){ place(armLeft, layout.left); place(armTop, layout.top); place(armRight, layout.right); placeFrame(); }
  });

  function pickArms(){
    const L = rc(classes), T = rc(classes), R = rc(classes);
    return {
      left: { cls: L, file: `${L}_left.webp` },
      top:  { cls: T, file: `${T}_sensitivity.webp` },
      right:{ cls: R, file: `${R}_right.webp` },
    };
  }

  function isChampion(arms){ return arms.left.cls===arms.top.cls && arms.left.cls===arms.right.cls; }

  async function enterArms(arms){
    setSrc(armLeft, arms.left.file); setSrc(armTop, arms.top.file); setSrc(armRight, arms.right.file);
    place(armLeft, layout.off.left); place(armTop, layout.off.top); place(armRight, layout.off.right);
    requestAnimationFrame(()=>{
      armLeft.style.opacity='1'; armTop.style.opacity='1'; armRight.style.opacity='1';
      armLeft.style.transform='rotate(0deg)'; armTop.style.transform='rotate(0deg)'; armRight.style.transform='rotate(0deg)';
      place(armLeft, layout.left); place(armTop, layout.top); place(armRight, layout.right);
    });
    await new Promise(r=>setTimeout(r, 1450));
    state = 'armsIn';
  }

  async function exitArms(){
    // rotate while leaving, slower ease-in
    requestAnimationFrame(()=>{
      armLeft.style.transform='rotate(-18deg)'; armTop.style.transform='rotate(-18deg)'; armRight.style.transform='rotate(18deg)';
      place(armLeft, layout.off.left); place(armTop, layout.off.top); place(armRight, layout.off.right);
      armLeft.style.opacity='0'; armTop.style.opacity='0'; armRight.style.opacity='0';
    });
    await new Promise(r=>setTimeout(r, 800));
    state = 'armsOut';
  });
    await new Promise(r=>setTimeout(r, 420));
    state = 'armsOut';
  }

  function showChampionPerimeter(){ placeFrame(); champFrame.classList.add('visible'); }

  centerCard.addEventListener('click', async ()=>{
    if(locked) { champFrame.classList.add('pulse'); setTimeout(()=>champFrame.classList.remove('pulse'), 800); return; }

    // clickable behavior depends on state
    if(state==='idle'){
      centerCard.classList.remove('clickable');
      const arms = pickArms();
      await enterArms(arms);
      if(isChampion(arms)){
        showChampionPerimeter();
        locked = true;
        // flip after small delay
        centerCard.style.transition = 'transform 320ms ease-in';
        centerCard.classList.add('squish');
        centerCard.addEventListener('transitionend', function onT(e){
          if(e.propertyName!=='transform') return;
          centerCard.removeEventListener('transitionend', onT);
          setSrc(centerCard, 'champion.webp');
          centerCard.style.transition = 'transform 380ms ease-out';
          centerCard.classList.remove('squish');
        });
      } else {
        // arms are in; next click should remove them
        centerCard.classList.add('clickable');
      }
    } else if(state==='armsIn'){
      centerCard.classList.remove('clickable');
      await exitArms();
      // arms are out; next click will bring new ones
      centerCard.classList.add('clickable');
    } else if(state==='armsOut'){
      centerCard.classList.remove('clickable');
      const arms = pickArms();
      await enterArms(arms);
      if(isChampion(arms)){
        showChampionPerimeter();
        locked = true;
        centerCard.style.transition = 'transform 320ms ease-in';
        centerCard.classList.add('squish');
        centerCard.addEventListener('transitionend', function onT(e){
          if(e.propertyName!=='transform') return;
          centerCard.removeEventListener('transitionend', onT);
          setSrc(centerCard, 'champion.webp');
          centerCard.style.transition = 'transform 380ms ease-out';
          centerCard.classList.remove('squish');
        });
      } else {
        centerCard.classList.add('clickable');
      }
    }
  });

  // Block context menu on visuals
  document.addEventListener('contextmenu', (e) => { if (e.target.closest('.stage, .logo, .bg')) e.preventDefault(); });
</script>
</body>
</html>
