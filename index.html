<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Car World Colosseum</title>
<link rel="icon" href="/favicon.png" />

<style>
html, body {
  height: 100%;
  margin: 0;
  background: transparent;
  overflow: hidden;          /* ← disables scrolling */
}

/* Add this here */
:root { --tail-lift: -0px; }  /* tweak this number */

  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif;
    color: #fff;
    background: #000;
    overscroll-behavior: none;
    touch-action: manipulation;
    user-select: none;
    padding-bottom: max(20px, env(safe-area-inset-bottom));
  }

  /* Red backdrop */
  .bg {
    position: fixed; inset: 0; z-index: -1;
    background-color: #7b0000;
    background-position: center; background-repeat: no-repeat; background-size: cover;
    background-image: url('RedBackdrop.webp?v=2');
  }

  /* Page layout */
  .wrap { min-height: 100svh; display: grid; grid-template-rows: auto 1fr auto; gap: 8px; padding: 6px 8px; }
  header { display: grid; place-items: center; }
  main   { display: grid; place-items: center; }
footer { 
  display: grid; 
  place-items: center; 
  margin-top: var(--tail-lift);
}

/* Move the © line by the same amount */
.wrap > div:last-child {
  margin-top: var(--tail-lift);
}


  /* logo controls */
  .logo {
  width: min(54vw, 320px);   /* keep your current logical size */
  height: auto;
  display: block;
  margin: 0 auto 2px;
  pointer-events: none;
  -webkit-user-drag: none;

  /* visually enlarge without changing layout box, and push it lower */
  transform: scale(1.55) translateY(26px); /* adjust px value to taste */
  transform-origin: center;
  will-change: transform;
}


  /* ↓ make stage a bit shorter so cards sit closer to both logo & footer */
  .stage { position: relative; width: min(92vw, 480px); height: min(66svh, 560px);
           margin: 0 auto; display:grid; place-items:center; }

  .cardArea { position: absolute; inset: 0; }
  .card     { position:absolute; image-rendering:auto; filter: drop-shadow(0 6px 16px rgba(0,0,0,.45)); }

  /* Body (center card) */
  .centerCard { cursor:pointer; transition: transform 320ms ease-in, filter 300ms ease-in-out; }
  .centerCard.squish { transform-origin:center; transform: scaleX(0.02); }


/* yellow "ready" pulse (unchanged) */
@keyframes pulseGlow {
  0%   { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  50%  { filter: drop-shadow(0 0 22px rgba(255,234,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  100% { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
}
.clickable { animation: pulseGlow 1.4s ease-in-out infinite; }

/* red "can't click" pulse for champion */
@keyframes pulseNoClickRed {
  0%   { filter: drop-shadow(0 0 0 rgba(255,0,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  45%  { filter: drop-shadow(0 0 22px rgba(255,0,0,.95)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  100% { filter: drop-shadow(0 0 0 rgba(255,0,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
}
.cantClickPulse {
  animation: pulseNoClickRed 1.05s ease-in-out 0s 2; /* 2 quick red pulses */
}


  /* Arms (slow entrances/exits) */
  :root { --arm-in-ms: 3000ms; --arm-out-ms: 1200ms; }
  .arm {
    opacity:0; pointer-events:none;
    transition:
      left var(--arm-in-ms) cubic-bezier(.16,1,.3,1),
      top  var(--arm-in-ms) cubic-bezier(.16,1,.3,1),
      transform var(--arm-in-ms) cubic-bezier(.16,1,.3,1),
      opacity 500ms ease-out;
  }

  /* Champion perimeter frame — hidden per request */
  .champFrame { display:none !important; }

  .cta { text-align:center; font-weight:700; letter-spacing:.02em; text-shadow:0 2px 8px rgba(0,0,0,.6); }
  .cta .small { opacity:.85; font-weight:600; }

  img { -webkit-user-drag: none; user-drag: none; }

/* ===== Visible overlay clickbox for testing ===== */
:root { --hotzone-top: 62vh; } /* tweak this to position the box */

#waitlistBox {
  position: fixed;
  left: 0; right: 0;
  top: var(--hotzone-top);
  bottom: 0;
  z-index: 9999;
  display: block;
  background: transparent;   /* invisible */
  outline: none;             /* no border */
  text-decoration: none;
  cursor: pointer;           /* optional: shows it's clickable */
}

/* keep an outline for keyboard users (optional but good a11y) */
#waitlistBox:focus-visible {
  outline: 2px solid rgba(255,255,255,.6);
  outline-offset: 2px;
}


</style>

<body>
  <div class="bg" aria-hidden="true"></div>

  <div class="wrap">
    <header>
      <img class="logo" src="logo.webp" alt="Car World Colosseum" width="900" height="522" />
    </header>

    <main>
      <div class="stage" id="stage" role="region" aria-label="Game stage">
        <div class="cardArea" id="cardArea">
          <img id="centerCard" class="card centerCard" alt="Attendant" />
          <img id="armLeft"   class="card arm" alt="Left Arm" />
          <img id="armTop"    class="card arm" alt="Top Arm" />
          <img id="armRight"  class="card arm" alt="Right Arm" />
          <div id="champFrame" class="champFrame" aria-hidden="true"></div>
        </div>
      </div>
</main>

<!-- Visible overlay clickbox linking to the waitlist (for testing) -->
<a id="waitlistBox"
   href="https://forms.gle/hJcNRWekxT2RLGMHA"
   target="_blank" rel="noopener"
   aria-label="Join the waiting list"></a>

<footer>

      <div class="cta">
        <div class="small">JOIN THE WAITING LIST</div>
        <div>FOR A CHANCE TO WIN A GOLDEN ATTENDANT</div>
      </div>
    </footer>

    <div style="text-align:center; font-size:0.8rem; opacity:0.75; padding:7px 0;">
      © 2025 Car World Colosseum
    </div>
  </div>

<script>
/* =======================  DATA  ======================= */
const manifest = [
  'RedBackdrop.webp', 'logo.webp', 'body.webp', 'champion.webp',
  'fighter_left.webp','fighter_right.webp','fighter_sensitivity.webp',
  'fucker_left.webp','fucker_right.webp','fucker_sensitivity.webp',
  'fracker_left.webp','fracker_right.webp','fracker_sensitivity.webp',
  'freak_left.webp','freak_right.webp','freak_sensitivity.webp',
];
const CLASSES = ['fighter','fucker','fracker','freak'];

/* =======================  ELTS  ======================= */
const stage      = document.getElementById('stage');
const centerCard = document.getElementById('centerCard');
const armLeft    = document.getElementById('armLeft');
const armTop     = document.getElementById('armTop');
const armRight   = document.getElementById('armRight');
const champFrame = document.getElementById('champFrame');

/* =======================  HELPERS  ======================= */
const preload = (url) => new Promise(res => { const i = new Image(); i.onload = i.onerror = res; i.src = url; });
const prewarm = async () => { for (const u of manifest) await preload(u); };
const setSrc  = (img, file) => { img.src = file; };
const rc      = (arr) => arr[Math.floor(Math.random()*arr.length)];

/* =======================  LAYOUT (3×2 T) — SCROLL-SAFE  ======================= */
let BODY_AR = 375/525; // default portrait ratio so we can place immediately
let layout  = null;    // {w,h, body, top, left, right, off, frame}
const PAD   = 6;

function computeLayout(){
  // Work in coordinates RELATIVE to the stage (no viewport left/top)
  const rW = stage.clientWidth;
  const rH = stage.clientHeight;

  const maxW   = (rW - PAD*2) / 3;
  const maxH   = (rH - PAD*2) / 2;
  const wFromH = maxH * BODY_AR;
  const cardW  = Math.min(maxW, wFromH);
  const cardH  = cardW / BODY_AR;

  const blockW = cardW * 3, blockH = cardH * 2;

  // bias upward inside the stage
  const freeY     = rH - blockH;
  const blockLeft = Math.round((rW - blockW)/2);
  const blockTop  = Math.round(freeY * 0.3);

  const col0 = blockLeft;
  const col1 = blockLeft + cardW;
  const col2 = blockLeft + cardW*2;
  const row0 = blockTop;
  const row1 = blockTop + cardH;

  layout = {
    w: cardW, h: cardH,
    body:  { left: col1, top: row1 }, // bottom-center
    top:   { left: col1, top: row0 },
    left:  { left: col0, top: row1 },
    right: { left: col2, top: row1 },
    off: {
      // Off-screen locations also relative to stage
      left:  { left: col0 - rW, top: row1 },
      top:   { left: col1,      top: row0 - rH },
      right: { left: col2 + rW, top: row1 },
    },
    frame: { left: blockLeft, top: blockTop, width: blockW, height: blockH },
  };
}

function place(el, rect){
  el.style.width  = layout.w + 'px';
  el.style.height = layout.h + 'px';
  el.style.left   = rect.left + 'px';
  el.style.top    = rect.top  + 'px';
}
function placeCenter(){ place(centerCard, layout.body); }

function positionHotzone(){
  const hz = document.getElementById('waitlistBox');
  if (!hz || !layout) return;

  // Body’s bottom (in viewport coords): stage top + body top + card height
  const stageRect = stage.getBoundingClientRect();
  const bodyBottom = stageRect.top + layout.body.top + layout.h;

  // Start the hotzone a few pixels below the body
  const offset = 6; // tweak this gap if you want
  hz.style.top = Math.max(0, Math.round(bodyBottom + offset)) + 'px';
  hz.style.left = '0';
  hz.style.right = '0';
  hz.style.bottom = '0'; // extends to bottom of viewport
}

/* Keep layout correct on resize/scroll (and move the waitlist hotzone) */
function relayoutVisible(){
  computeLayout();
  placeCenter();

  if (state === 'armsIn') {
    place(armLeft, layout.left);
    place(armTop,  layout.top);
    place(armRight,layout.right);
  } else {
    place(armLeft, layout.off.left);
    place(armTop,  layout.off.top);
    place(armRight,layout.off.right);
  }

  positionHotzone();
}

window.addEventListener('resize', relayoutVisible);
window.addEventListener('scroll',  relayoutVisible, { passive: true });


/* =======================  STATE  ======================= */
let state = 'boot';          // 'idle' (no arms), 'armsIn' (visible), 'armsOut' (hidden)
let locked = false;          // champion lock
let busy   = false;          // click guard while animating
let pendingArms = null;      // holds the set used for the next "enter" action

/* =======================  INIT  ======================= */
async function init(){
computeLayout(); placeCenter(); positionHotzone();

  centerCard.onload = () => {
    if (centerCard.naturalWidth) {
      BODY_AR = centerCard.naturalWidth / centerCard.naturalHeight;
      computeLayout(); placeCenter(); positionHotzone();
    }
  };
  setSrc(centerCard, 'body.webp');

  await prewarm();
  centerCard.classList.add('clickable');
  state = 'idle';
}
init();

window.addEventListener('resize', () => {
  computeLayout(); placeCenter(); positionHotzone();
  if (state === 'armsIn') { place(armLeft, layout.left); place(armTop, layout.top); place(armRight, layout.right); }
});

/* =======================  GAME LOGIC  ======================= */
function pickArms(){
  const L = rc(CLASSES), T = rc(CLASSES), R = rc(CLASSES);
  return {
    left:  { cls:L, file: `${L}_left.webp` },
    top:   { cls:T, file: `${T}_sensitivity.webp` },
    right: { cls:R, file: `${R}_right.webp` },
  };
}
function isChampion(a){ return a.left.cls === a.top.cls && a.left.cls === a.right.cls; }

async function enterArms(arms){
  setSrc(armLeft,  arms.left.file);
  setSrc(armTop,   arms.top.file);
  setSrc(armRight, arms.right.file);

  place(armLeft,  layout.off.left);
  place(armTop,   layout.off.top);
  place(armRight, layout.off.right);

  requestAnimationFrame(() => {
    armLeft.style.opacity='1'; armTop.style.opacity='1'; armRight.style.opacity='1';
    armLeft.style.transform='rotate(0deg)'; armTop.style.transform='rotate(0deg)'; armRight.style.transform='rotate(0deg)';
    place(armLeft, layout.left); place(armTop, layout.top); place(armRight, layout.right);
  });

  await new Promise(r => setTimeout(r, 3000 + 60));
  state = 'armsIn';
}

async function exitArms(){
  requestAnimationFrame(() => {
    armLeft.style.transform='rotate(-18deg)'; armTop.style.transform='rotate(-18deg)'; armRight.style.transform='rotate(18deg)';
    place(armLeft, layout.off.left);
    place(armTop,  layout.off.top);
    place(armRight,layout.off.right);
    armLeft.style.opacity='0'; armTop.style.opacity='0'; armRight.style.opacity='0';
  });
  await new Promise(r => setTimeout(r, 1200 + 60));
  state = 'armsOut';
}

/* =======================  INTERACTION  ======================= */
function pulseCantClick() {
  const els = [centerCard, armLeft, armTop, armRight];
  els.forEach(el => {
    // ensure we don't stack pulses
    el.classList.remove('cantClickPulse');
    // kick (reflow) so re-adding animation restarts it
    void el.offsetWidth;
    el.classList.add('cantClickPulse');
    el.addEventListener('animationend', function onA() {
      el.classList.remove('cantClickPulse');
      el.removeEventListener('animationend', onA);
    }, { once: true });
  });
}

centerCard.addEventListener('click', async () => {
  if (busy) return;

  // If champion is showing, clicks only produce a red "can't click" pulse.
  if (locked) {
    pulseCantClick();
    return;
  }

  busy = true;

  if (state === 'idle' || state === 'armsOut') {
    centerCard.classList.remove('clickable');
    if (!pendingArms) pendingArms = pickArms();
    await enterArms(pendingArms);

    if (isChampion(pendingArms)) {
      locked = true;
      centerCard.classList.remove('clickable');
      centerCard.classList.add('squish');
      centerCard.addEventListener('transitionend', function onT(e){
        if (e.propertyName !== 'transform') return;
        centerCard.removeEventListener('transitionend', onT);
        setSrc(centerCard, 'champion.webp');
        centerCard.style.transition = 'transform 380ms ease-out';
        centerCard.classList.remove('squish');
      }, { once:true });
    } else {
      centerCard.classList.add('clickable');
      pendingArms = null;
    }

  } else if (state === 'armsIn') {
    centerCard.classList.remove('clickable');
    await exitArms();
    centerCard.classList.add('clickable');
  }

  busy = false;
});


/* Deter saving from the stage/logo/bg */
document.addEventListener('contextmenu', (e) => {
  if (e.target.closest('.stage, .logo, .bg')) e.preventDefault();
});
</script>
</body>
</html>
