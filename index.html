<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Car World Colosseum</title>
  <link rel="icon" href="/favicon.png" />
  <link rel="preload" href="./blackbeardregular-webfont.woff2" as="font" type="font/woff2" crossorigin>

  <style>
  /* BlackBeard font + page fade-in curtain */
  @font-face{
    font-family: "BlackBeard";
    src: url("./blackbeardregular-webfont.woff2") format("woff2"); /* adjust path if in /fonts */
    font-weight: 400;
    font-style: normal;
    font-display: swap;
  }

html{
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

html, body {
  height: 100%;
  margin: 0;
  background: transparent;
  overflow: hidden;          /* ← disables scrolling */
}

/* --- page fade-in curtain --- */
#curtain{
  position: fixed;
  inset: 0;
  background: #000;               /* start fully black */
  z-index: 2147483646;            /* just below #waitlistBox (…47) */
  opacity: 1;
  transition: opacity 2.5s ease;  /* 2.5s fade */
}

/* when ready, fade away (add .ready to <body> in JS) */
body.ready #curtain{
  opacity: 0;
  pointer-events: none;           /* stop blocking clicks after fade */
}

body {
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif;
  color: #fff;
  background: #000;
  overscroll-behavior: none;
  touch-action: manipulation;
  user-select: none;
  padding-bottom: max(20px, env(safe-area-inset-bottom));
}

/* Red backdrop */
.bg {
  position: fixed; inset: 0; z-index: -1;
  background-color: #7b0000;
  background-position: center; background-repeat: no-repeat; background-size: cover;
  background-image: url('RedBackdrop.webp?v=2');
}

/* Page layout */
.wrap { min-height: 100vh; display: grid; grid-template-rows: auto 1fr auto; gap: 8px; padding: 6px 8px; }
header { display: grid; place-items: center; }
main   { display: grid; place-items: center; }
footer {
  position: fixed;           /* fixed so we can place it precisely */
  left: 0;
  right: 0;
  top: 70vh;                 /* temporary; JS will set exact top */
  z-index: 10000;            /* above the hotzone (9999) */
  display: grid;
  place-items: center;
  gap: 4px;
  padding: 8px 8px max(12px, env(safe-area-inset-bottom));
}

/* logo controls */
.logo {
  width: min(54vw, 320px);   /* keep your current logical size */
  height: auto;
  display: block;
  margin: 0 auto 2px;
  pointer-events: none;
  -webkit-user-drag: none;

  /* visually enlarge without changing layout box, and push it lower */
  transform: scale(1.55) translateY(26px); /* adjust px value to taste */
  transform-origin: center;
  will-change: transform;
}

/* ↓ make stage a bit shorter so cards sit closer to both logo & footer */
.stage { position: relative; width: min(92vw, 480px); height: min(66vh, 560px);
         margin: 0 auto; display:grid; place-items:center; }

/* ===== progressive viewport units ===== */
@supports (height: 1svh) {
  .wrap  { min-height: 100svh; }
  .stage { height: min(66svh, 560px); }
}
@supports (height: 1dvh) {
  .wrap  { min-height: 100dvh; }
  .stage { height: min(66dvh, 560px); }
}
/* ===== end progressive units ===== */

.cardArea { position: absolute; inset: 0; }
.card     { position:absolute; image-rendering:auto; filter: drop-shadow(0 6px 16px rgba(0,0,0,.45)); }

/* Body (center card) */
/* CHANGED: slower, smoother transform easing */
.centerCard { cursor:pointer; transition: transform 520ms cubic-bezier(.22,1,.36,1), filter 300ms ease-in-out; }
.centerCard.squish { transform-origin:center; transform: scaleX(0.02); }

/* yellow "ready" pulse (unchanged) */
@keyframes pulseGlow {
  0%   { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  50%  { filter: drop-shadow(0 0 22px rgba(255,234,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  100% { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
}
.clickable { animation: pulseGlow 1.4s ease-in-out infinite; }

/* red "can't click" pulse for champion */
@keyframes pulseNoClickRed {
  0%   { filter: drop-shadow(0 0 0 rgba(255,0,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  45%  { filter: drop-shadow(0 0 22px rgba(255,0,0,.95)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  100% { filter: drop-shadow(0 0 0 rgba(255,0,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
}
.cantClickPulse {
  animation: pulseNoClickRed 1.05s ease-in-out 0s 2; /* 2 quick red pulses */
}

/* Arms (slow entrances/exits) */
/* CHANGED: timings + easing + GPU hints */
:root { --arm-in-ms: 3600ms; --arm-out-ms: 1400ms; }
.arm {
  opacity:0; pointer-events:none;
  transition:
    left var(--arm-in-ms) cubic-bezier(.22,1,.36,1),
    top  var(--arm-in-ms) cubic-bezier(.22,1,.36,1),
    transform var(--arm-in-ms) cubic-bezier(.22,1,.36,1),
    opacity 500ms ease-out;
  backface-visibility: hidden;
  will-change: left, top, transform;
  transform: translateZ(0);
}

/* Champion perimeter frame — hidden per request */
.champFrame { display:none !important; }

/* CTA text */
.cta { 
  font-family: "BlackBeard", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif;
  text-align: center;
  font-weight: 400;
  letter-spacing: .02em;
  text-shadow: 0 2px 8px rgba(0,0,0,.6);
  line-height: 0.9
;
  font-size: 1.5em;   /* ~50% bigger */
}

/* iOS-only size guard for CTA (A+B addition) */
@supports (-webkit-touch-callout: none) {
  .cta {
    font-size: clamp(18px, 4.2vw, 28px);
    line-height: 1.05;
  }
}

/* colored words */
.cta .blue { color: #4DA3FF; }     /* WAITLIST */
.cta .gold {
  color: #FFD166; 
  text-shadow:
    0 0 6px rgba(255, 209, 102, 0.8),
    0 0 12px rgba(255, 209, 102, 0.6),
    0 0 20px rgba(255, 209, 102, 0.5);
}    /* GOLDEN ATTENDANT */

/* default: stack to 3 lines on mobile */
.cta .line { display: block; }

/* desktop and wider: collapse to one row */
@media (min-width: 700px){
  .cta {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-wrap: nowrap;
    gap: .4ch;                     /* small spacing between segments */
  }
  .cta .line { display: inline; }
}

.copyright {
  text-align: center;
  font-size: 0.8rem;
  opacity: 0.75;
}

img { -webkit-user-drag: none; user-drag: none; }

/* ===== Visible overlay clickbox for testing ===== */
#waitlistBox{
  position: fixed;
  left: 0; right: 0;
  z-index: 2147483647;      /* sit above everything */
  display: block;
  pointer-events: auto;     /* make sure it can receive clicks */
  background: transparent !important;
  border: 0 !important;
  outline: none !important;
  text-decoration: none;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  touch-action: manipulation;

  /* TEMP while testing so you can see it; remove later */
  background: rgba(0,255,255,.18) !important;
  outline: 1px dashed #00ced1;
}

/* TEMP iOS test: disable the big overlay entirely */
/#waitlistBox { display: none !important; }/
</style>
</head>

<body>
  <!-- Curtain must be first so it covers everything -->
  <div id="curtain" aria-hidden="true"></div>

  <!-- Single background -->
  <div class="bg" aria-hidden="true"></div>

  <!-- Single wrapper -->
  <div class="wrap">
    <header>
      <img class="logo" src="logo.webp" alt="Car World Colosseum" width="900" height="522" />
    </header>

    <main>
      <div class="stage" id="stage" role="region" aria-label="Game stage">
        <div class="cardArea" id="cardArea">
          <img id="centerCard" class="card centerCard" alt="Attendant" />
          <img id="armLeft"   class="card arm" alt="Left Arm" />
          <img id="armTop"    class="card arm" alt="Top Arm" />
          <img id="armRight"  class="card arm" alt="Right Arm" />
          <div id="champFrame" class="champFrame" aria-hidden="true"></div>
        </div>
      </div>
    </main>

    <!-- Visible overlay clickbox linking to the waitlist (for testing) -->
    <a id="waitlistBox"
       href="https://forms.gle/hJcNRWekxT2RLGMHA"
       target="_blank" rel="noopener"
       aria-label="Join the waiting list"></a>

    <footer>
      <div class="cta" role="text">
        <span class="line">JOIN THE <span class="blue">WAITLIST</span></span>
        <span class="line">FOR A CHANCE TO WIN</span>
        <span class="line">A <span class="gold">GOLDEN ATTENDANT</span></span>
      </div>
      <div class="copyright">© 2025 Car World Colosseum</div>
    </footer>
  </div>

<script>
/* =======================  DATA  ======================= */
const manifest = [
  'RedBackdrop.webp', 'logo.webp', 'body.webp', 'champion.webp',
  'fighter_left.webp','fighter_right.webp','fighter_sensitivity.webp',
  'fucker_left.webp','fucker_right.webp','fucker_sensitivity.webp',
  'fracker_left.webp','fracker_right.webp','fracker_sensitivity.webp',
  'freak_left.webp','freak_right.webp','freak_sensitivity.webp',
];
const CLASSES = ['fighter','fucker','fracker','freak'];

/* =======================  ELTS  ======================= */
const stage      = document.getElementById('stage');
const centerCard = document.getElementById('centerCard');
const armLeft    = document.getElementById('armLeft');
const armTop     = document.getElementById('armTop');
const armRight   = document.getElementById('armRight');
const champFrame = document.getElementById('champFrame');

/* =======================  HELPERS  ======================= */
const preload = (url) => new Promise(res => { const i = new Image(); i.onload = i.onerror = res; i.src = url; });
const prewarm = async () => { for (const u of manifest) await preload(u); };
const setSrc  = (img, file) => { img.src = file; };
const rc      = (arr) => arr[Math.floor(Math.random()*arr.length)];

/* =======================  LAYOUT (3×2 T) — SCROLL-SAFE  ======================= */
let BODY_AR = 375/525; // default portrait ratio so we can place immediately
let layout  = null;    // {w,h, body, top, left, right, off, frame}
const PAD   = 6;

function computeLayout(){
  // Work in coordinates RELATIVE to the stage (no viewport left/top)
  const rW = stage.clientWidth;
  const rH = stage.clientHeight;

  const maxW   = (rW - PAD*2) / 3;
  const maxH   = (rH - PAD*2) / 2;
  const wFromH = maxH * BODY_AR;
  const cardW  = Math.min(maxW, wFromH);
  const cardH  = cardW / BODY_AR;

  const blockW = cardW * 3, blockH = cardH * 2;

  // bias upward inside the stage
  const freeY     = rH - blockH;
  const blockLeft = Math.round((rW - blockW)/2);
  const blockTop  = Math.round(freeY * 0.3);

  const col0 = blockLeft;
  const col1 = blockLeft + cardW;
  const col2 = blockLeft + cardW*2;
  const row0 = blockTop;
  const row1 = blockTop + cardH;

  layout = {
    w: cardW, h: cardH,
    body:  { left: col1, top: row1 }, // bottom-center
    top:   { left: col1, top: row0 },
    left:  { left: col0, top: row1 },
    right: { left: col2, top: row1 },
    off: {
      // Off-screen locations also relative to stage
      left:  { left: col0 - rW, top: row1 },
      top:   { left: col1,      top: row0 - rH },
      right: { left: col2 + rW, top: row1 },
    },
    frame: { left: blockLeft, top: blockTop, width: blockW, height: blockH },
  };
}

function place(el, rect){
  el.style.width  = layout.w + 'px';
  el.style.height = layout.h + 'px';
  el.style.left   = rect.left + 'px';
  el.style.top    = rect.top  + 'px';
}
function placeCenter(){ place(centerCard, layout.body); }

function positionHotzone(){
  const hz = document.getElementById('waitlistBox');
  if (!hz || !layout) return;

  const stageRect  = stage.getBoundingClientRect();
  const bodyBottom = stageRect.top + layout.body.top + layout.h;

  const topPx = Math.max(0, Math.round(bodyBottom + 1)); // 1px gap

  // ===== overlay guard patch (added) =====
  const minTop = Math.round(bodyBottom - layout.h * 0.2); // never jump above near-body area
  hz.style.top = Math.max(topPx, minTop) + 'px';
  // ===== end patch =====

  hz.style.bottom = '0';
  hz.style.left = '0';
  hz.style.right = '0';
  hz.style.display = 'block';
}

function positionFooter() {
  const footer = document.querySelector('footer');
  if (!footer || !layout) return;

  // measure footer height (ensure it’s rendered)
  footer.style.visibility = 'hidden';
  footer.style.top = '0px';
  footer.style.bottom = '';
  footer.style.display = 'grid';
  const footerH = footer.getBoundingClientRect().height || 0;
  footer.style.visibility = '';

  // body bottom in viewport coords: stage top + body top + card height
  const stageRect = stage.getBoundingClientRect();
  const bodyBottom = stageRect.top + layout.body.top + layout.h;

  // place footer 10px below the body, but keep it on-screen
  const gap = 10;
  let topPx = Math.round(bodyBottom + gap);

  // clamp: never let footer go off bottom edge
  const maxTop = Math.max(0, window.innerHeight - footerH);
  if (topPx > maxTop) topPx = maxTop;

  footer.style.top = topPx + 'px';
  footer.style.bottom = ''; // we’re anchoring by top
}

/* Keep layout correct on resize/scroll (and move the waitlist hotzone) */
function relayoutVisible(){
  computeLayout();
  placeCenter();

  if (state === 'armsIn') {
    place(armLeft, layout.left);
    place(armTop,  layout.top);
    place(armRight,layout.right);
  } else {
    place(armLeft, layout.off.left);
    place(armTop,  layout.off.top);
    place(armRight,layout.off.right);
  }

  positionHotzone();
  positionFooter();

}

window.addEventListener('resize', relayoutVisible);
window.addEventListener('scroll',  relayoutVisible, { passive: true });

/* =======================  STATE  ======================= */
let state = 'boot';          // 'idle' (no arms), 'armsIn' (visible), 'armsOut' (hidden)
let locked = false;          // champion lock
let busy   = false;          // click guard while animating
let pendingArms = null;      // holds the set used for the next "enter" action

/* =======================  INIT  ======================= */
async function init(){
  computeLayout(); placeCenter(); positionHotzone(); positionFooter();

  centerCard.onload = () => {
    if (centerCard.naturalWidth) {
      BODY_AR = centerCard.naturalWidth / centerCard.naturalHeight;
      computeLayout(); placeCenter(); positionHotzone(); positionFooter();
    }
  };
  setSrc(centerCard, 'body.webp');

  await prewarm();                     // images/fonts warmed
  centerCard.classList.add('clickable');
  state = 'idle';

  // ↓ start the fade-out AFTER everything's ready
  requestAnimationFrame(() => {
    document.body.classList.add('ready');

    // remove the curtain after the fade completes
    const curtain = document.getElementById('curtain');
    if (curtain) {
      curtain.addEventListener('transitionend', () => curtain.remove(), { once: true });
      // fallback in case transitionend doesn't fire
      setTimeout(() => curtain && curtain.remove(), 1200);
    }
  });
}

init();

window.addEventListener('resize', () => {
  computeLayout(); placeCenter(); positionHotzone(); positionFooter();
  if (state === 'armsIn') { place(armLeft, layout.left); place(armTop, layout.top); place(armRight, layout.right); }
});

/* =======================  GAME LOGIC  ======================= */
function pickArms(){
  const L = rc(CLASSES), T = rc(CLASSES), R = rc(CLASSES);
  return {
    left:  { cls:L, file: `${L}_left.webp` },
    top:   { cls:T, file: `${T}_sensitivity.webp` },
    right: { cls:R, file: `${R}_right.webp` },
  };
}
function isChampion(a){ return a.left.cls === a.top.cls && a.left.cls === a.right.cls; }

async function enterArms(arms){
  setSrc(armLeft,  arms.left.file);
  setSrc(armTop,   arms.top.file);
  setSrc(armRight, arms.right.file);

  place(armLeft,  layout.off.left);
  place(armTop,   layout.off.top);
  place(armRight, layout.off.right);

  requestAnimationFrame(() => {
    armLeft.style.opacity='1'; armTop.style.opacity='1'; armRight.style.opacity='1';
    armLeft.style.transform='rotate(0deg)'; armTop.style.transform='rotate(0deg)'; armRight.style.transform='rotate(0deg)';
    place(armLeft, layout.left); place(armTop, layout.top); place(armRight, layout.right);
  });

  await new Promise(r => setTimeout(r, 3000 + 60));
  state = 'armsIn';
}

async function exitArms(){
  requestAnimationFrame(() => {
    armLeft.style.transform='rotate(-18deg)'; armTop.style.transform='rotate(-18deg)'; armRight.style.transform='rotate(18deg)';
    place(armLeft, layout.off.left);
    place(armTop,  layout.off.top);
    place(armRight,layout.off.right);
    armLeft.style.opacity='0'; armTop.style.opacity='0'; armRight.style.opacity='0';
  });
  await new Promise(r => setTimeout(r, 1200 + 60));
  state = 'armsOut';
}

/* =======================  INTERACTION  ======================= */
function pulseCantClick() {
  const els = [centerCard, armLeft, armTop, armRight];
  els.forEach(el => {
    // ensure we don't stack pulses
    el.classList.remove('cantClickPulse');
    // kick (reflow) so re-adding animation restarts it
    void el.offsetWidth;
    el.classList.add('cantClickPulse');
    el.addEventListener('animationend', function onA() {
      el.classList.remove('cantClickPulse');
      el.removeEventListener('animationend', onA);
    }, { once: true });
  });
}

centerCard.addEventListener('click', async () => {
  if (busy) return;

  // If champion is showing, clicks only produce a red "can't click" pulse.
  if (locked) {
    pulseCantClick();
    return;
  }

  busy = true;

  if (state === 'idle' || state === 'armsOut') {
    centerCard.classList.remove('clickable');
    if (!pendingArms) pendingArms = pickArms();
    await enterArms(pendingArms);

    if (isChampion(pendingArms)) {
      locked = true;
      centerCard.classList.remove('clickable');
      centerCard.classList.add('squish');
      centerCard.addEventListener('transitionend', function onT(e){
        if (e.propertyName !== 'transform') return;
        centerCard.removeEventListener('transitionend', onT);
        setSrc(centerCard, 'champion.webp');
        /* CHANGED: slower, smoother flip-out */
        centerCard.style.transition = 'transform 600ms cubic-bezier(.22,1,.36,1)';
        centerCard.classList.remove('squish');
      }, { once:true });
    } else {
      centerCard.classList.add('clickable');
      pendingArms = null;
    }

  } else if (state === 'armsIn') {
    centerCard.classList.remove('clickable');
    await exitArms();
    centerCard.classList.add('clickable');
  }

  busy = false;
});

/* Deter saving from the stage/logo/bg */
document.addEventListener('contextmenu', (e) => {
  if (e.target.closest('.stage, .logo, .bg')) e.preventDefault();
});
</script>
</body>
</html>
