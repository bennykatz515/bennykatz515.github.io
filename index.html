<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Car World Colosseum</title>
<!-- Keep your favicon setup from earlier -->
<link rel="icon" href="/favicon.png" />

<style>
  :root {
    --safe-padding: env(safe-area-inset-top, 0) env(safe-area-inset-right, 0) env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0);
  }
  html, body { height: 100%; margin: 0; background: transparent; }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif;
    color: #fff;
    background: #000; /* fallback color while image loads */
    overscroll-behavior: none;
    touch-action: manipulation;
    user-select: none;
  }
  /* Responsive background using AVIF with WebP fallback */
  .bg {
    position: fixed; inset: 0; z-index: -1;
    /* Solid red fallback behind the image; 'cover' to avoid odd stretching */
    background-color: #7b0000;
    background-position: center; background-repeat: no-repeat; background-size: cover;
    background-image: url('RedBackdrop.webp?v=1');
  }
  @supports (background-image: image-set(url('x.avif') type('image/avif'))) {
    .bg { background-image: image-set(url('RedBackdrop.webp') type('image/webp') 1x); }
  }
  @supports (background-image: image-set(url('x.avif') type('image/avif'))) {
    .bg {
      background-image: image-set(
        url('RedBackdrop.avif') type('image/avif') 1x,
        url('RedBackdrop.webp') type('image/webp') 1x
      );
    }
  }

  /* Overlay to deter long-press/save and catch right-clicks */

  /* Layout */
  .wrap { min-height: 100svh; display: grid; grid-template-rows: auto 1fr auto; padding: 8px; }
  header { display: grid; place-items: center; padding: 8px 0; }
  main { display: grid; place-items: center; }
  footer { display: grid; place-items: center; padding: 16px 0; }

  .logo { width: min(70vw, 520px); height: auto; pointer-events: none; -webkit-user-drag: none; }
  .stage { position: relative; width: min(92vw, 480px); height: min(78svh, 720px); border-radius: 12px; overflow: visible; box-shadow: none; margin-top: 6px; }
  .cardArea { position: absolute; inset: 0; }
  .card { position:absolute; width:0; height:0; image-rendering:auto; filter: drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  .centerCard { transition: transform 220ms ease-in, filter 300ms ease-in-out; cursor:pointer; }
  .centerCard.squish { transform-origin:center; transform: scaleX(0.02); }
  /* Pulsing clickable glow */
  @keyframes pulseGlow { 0% { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); } 50% { filter: drop-shadow(0 0 22px rgba(255,234,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); } 100% { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); } }
  .clickable { animation: pulseGlow 1.2s ease-in-out infinite; }

  /* Arms */
  .arm { opacity:0; pointer-events:none; transition: left 1400ms cubic-bezier(.22,1,.36,1), top 1400ms cubic-bezier(.22,1,.36,1), opacity 380ms ease-out; }
  .championGlow { filter: drop-shadow(0 0 24px rgba(255,0,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.55)); }
  .centerCard.squish { transform:translate(-50%,-50%) scaleX(0.02); }
  /* Pulsing clickable glow */
  @keyframes pulseGlow {
    0% { filter: drop-shadow(0 0 0 rgba(255, 234, 0, 0.0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
    50% { filter: drop-shadow(0 0 22px rgba(255, 234, 0, .9)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
    100% { filter: drop-shadow(0 0 0 rgba(255, 234, 0, 0.0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  }
  .clickable { animation: pulseGlow 1.2s ease-in-out infinite; }

  /* Arms */
  .arm { position:absolute; opacity:0; pointer-events:none; transition: transform 1200ms cubic-bezier(.22,1,.36,1), opacity 320ms ease-out, left 1200ms cubic-bezier(.22,1,.36,1), top 1200ms cubic-bezier(.22,1,.36,1); filter: drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  .armLeft { transform: translate(-160%, 0); }
  .armTop { transform: translate(0, -160%); }
  .armRight { transform: translate(160%, 0); }
  .arm.in { opacity:1; transform: translate(0,0); }
  .armLeft { transform: translate(-140%, 0); }
  .armTop { transform: translate(0, -140%); }
  .armRight { transform: translate(140%, 0); }
  .arm.in { opacity:1; transform: translate(0,0); }
  .armLeft { left: 5%; top: 50%; transform: translate(-120%, -50%); }
  .armTop { left: 50%; top: 8%; transform: translate(-50%, -120%); height:36%; }
  .armRight { right: 5%; top: 50%; transform: translate(120%, -50%); }
  .arm.in { opacity:1; }
  /* Final snap positions next to body */
  
  .snapTop { left: 50%; top: 18%; transform: translate(-50%, 0); }
  .snapRight { right: 13%; top: 50%; transform: translate(0, -50%); }

  /* Champion red glow for all four */
  .championGlow { filter: drop-shadow(0 0 24px rgba(255,0,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.55)); }

  .centerCard.squish { transform:translate(-50%,-50%) scaleX(0.02); }
  .centerCard.squish { transform:translate(-50%,-50%) scaleX(0.02); }

  /* CTA text example; you can replace with your styled image later */
  .cta { text-align: center; font-weight: 700; letter-spacing: .02em; text-shadow: 0 2px 8px rgba(0,0,0,.6); }
  .cta .small { opacity: .85; font-weight: 600; }

  /* Loading gate */

  /* Prevent image dragging/selection globally */
  img { -webkit-user-drag: none; user-drag: none; }
  [data-interactive] { pointer-events: auto; }
</style>

<body>
  <div class="bg" aria-hidden="true"></div>
  <div class="wrap">
    <header>
      <img class="logo" src="logo.webp" alt="Car World Colosseum" width="900" height="522" />
    </header>

    <main>
      <div class="stage" id="stage" role="region" aria-label="Game stage">
        <div class="cardArea" id="cardArea">
          <img id="centerCard" class="card centerCard" alt="Attendant" />
          <img id="armLeft" class="card arm armLeft" alt="Left Arm" />
          <img id="armTop" class="card arm armTop" alt="Top Arm" />
          <img id="armRight" class="card arm armRight" alt="Right Arm" />
        </div>
      </div>
    </main>

    <footer>
      <div class="cta">
        <div class="small">JOIN THE WAITING LIST</div>
        <div>FOR A CHANCE TO WIN A GOLDEN ATTENDANT</div>
      </div>
    </footer>

    <div style="text-align:center; font-size:0.85rem; opacity:0.75; padding:8px 0;">
      Â© 2025 Car World Colosseum
    </div>
  </div>  </div>

<script>
  /* ------------------------------------------------------------
   * Equal-size cards layout (T shape) + slow arm entrances + champion flip
   * ---------------------------------------------------------- */
  const manifest = [
    'RedBackdrop.webp', 'logo.webp', 'body.webp', 'champion.webp',
    'fighter_left.webp','fighter_right.webp','fighter_sensitivity.webp',
    'fucker_left.webp','fucker_right.webp','fucker_sensitivity.webp',
    'fracker_left.webp','fracker_right.webp','fracker_sensitivity.webp',
    'freak_left.webp','freak_right.webp','freak_sensitivity.webp',
  ];

  const classes = ['fighter','fucker','fracker','freak'];

  // Elements
  const stage = document.getElementById('stage');
  const centerCard = document.getElementById('centerCard');
  const armLeft = document.getElementById('armLeft');
  const armTop = document.getElementById('armTop');
  const armRight = document.getElementById('armRight');
  const armsArr = [armLeft, armTop, armRight];

  function preload(url) {
    return new Promise((resolve) => {
      if (!/\.(webp|png|jpg|jpeg|gif|svg)(\?.*)?$/i.test(url)) { resolve(); return; }
      const img = new Image();
      img.onload = img.onerror = () => resolve();
      img.src = url;
    });
  }
  async function prewarm(){ for(const u of manifest) await preload(u); }
  function setSrc(img, file){ img.src = file; }
  function rc(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // Compute equal card size and absolute positions (no gaps)
  let layout = null;
  function computeLayout(){
    const r = stage.getBoundingClientRect();
    // We need room for 2 card heights stacked; let card be min of width and height/2
    const card = Math.min(r.width, r.height/2);
    const bodyX = Math.round(r.left + (r.width - card)/2);
    const bodyY = Math.round(r.top + r.height - card); // bottom-aligned

    layout = {
      size: card,
      body: { left: bodyX, top: bodyY },
      top: { left: bodyX, top: bodyY - card },
      left: { left: bodyX - card, top: bodyY },
      right: { left: bodyX + card, top: bodyY },
      // offscreen starts
      off: {
        left: { left: bodyX - card - r.width, top: bodyY },
        top:  { left: bodyX, top: bodyY - card - r.height },
        right:{ left: bodyX + card + r.width, top: bodyY },
      }
    };
  }

  function applyRect(el, rect){
    const stageRect = stage.getBoundingClientRect();
    el.style.width = layout.size + 'px';
    el.style.height = layout.size + 'px';
    el.style.left = (rect.left - stageRect.left) + 'px';
    el.style.top  = (rect.top - stageRect.top) + 'px';
  }

  function placeCenter(){ applyRect(centerCard, layout.body); }

  let busy = true, locked = false;

  (async function init(){
    await prewarm();
    computeLayout();
    setSrc(centerCard, 'body.webp');
    placeCenter();
    centerCard.classList.add('clickable');
    busy = false;
  })();

  window.addEventListener('resize', () => {
    computeLayout();
    placeCenter();
    if(armLeft.classList.contains('in')){ applyRect(armLeft, layout.left); }
    if(armTop.classList.contains('in')){ applyRect(armTop, layout.top); }
    if(armRight.classList.contains('in')){ applyRect(armRight, layout.right); }
  });

  function pickArms(){
    const L = rc(classes), T = rc(classes), R = rc(classes);
    return {
      left: { cls: L, file: `${L}_left.webp` },
      top:  { cls: T, file: `${T}_sensitivity.webp` },
      right:{ cls: R, file: `${R}_right.webp` },
    };
  }

  function isChampion(arms){ return arms.left.cls===arms.top.cls && arms.left.cls===arms.right.cls; }
  function clearChampionGlow(){ [centerCard, ...armsArr].forEach(el=>el.classList.remove('championGlow')); }
  function applyChampionGlow(){ [centerCard, ...armsArr].forEach(el=>el.classList.add('championGlow')); }

  function armsEnter(arms){
    setSrc(armLeft, arms.left.file); setSrc(armTop, arms.top.file); setSrc(armRight, arms.right.file);
    // start offscreen
    applyRect(armLeft, layout.off.left); applyRect(armTop, layout.off.top); applyRect(armRight, layout.off.right);
    // next frame slide to targets
    requestAnimationFrame(()=>{
      armLeft.style.opacity = '1'; armTop.style.opacity='1'; armRight.style.opacity='1';
      applyRect(armLeft, layout.left); applyRect(armTop, layout.top); applyRect(armRight, layout.right);
      armLeft.classList.add('in'); armTop.classList.add('in'); armRight.classList.add('in');
    });
    return new Promise(r=>setTimeout(r, 1450));
  }

  function armsExit(){
    requestAnimationFrame(()=>{
      applyRect(armLeft, layout.off.left); applyRect(armTop, layout.off.top); applyRect(armRight, layout.off.right);
      armLeft.style.opacity = '0'; armTop.style.opacity='0'; armRight.style.opacity='0';
      armLeft.classList.remove('in'); armTop.classList.remove('in'); armRight.classList.remove('in');
    });
    return new Promise(r=>setTimeout(r, 380));
  }

  function flipToChampion(){
    centerCard.classList.remove('clickable');
    centerCard.style.transition = 'transform 220ms ease-in';
    centerCard.classList.add('squish');
  }

  centerCard.addEventListener('click', async ()=>{
    if(busy||locked) return; busy=true; clearChampionGlow(); centerCard.classList.remove('clickable');

    const armsVisible = armLeft.classList.contains('in');
    if(armsVisible){ await armsExit(); }

    const arms = pickArms();
    await armsEnter(arms);

    if(isChampion(arms)) { applyChampionGlow(); locked=true; flipToChampion(); }
    else { centerCard.classList.add('clickable'); busy=false; }
  });

  centerCard.addEventListener('transitionend', (e)=>{
    if(e.propertyName!=='transform') return;
    if(locked && centerCard.classList.contains('squish')){
      setSrc(centerCard, 'champion.webp');
      centerCard.style.transition = 'transform 260ms ease-out';
      centerCard.classList.remove('squish');
    }
  });

  // Block context menu on visuals
  document.addEventListener('contextmenu', (e) => {
    if (e.target.closest('.stage, .logo, .bg')) e.preventDefault();
  });
</script>
</body>
</html>
