<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Car World Colosseum</title>
  <link rel="icon" href="/favicon.png" />
  <link rel="preload" href="./blackbeardregular-webfont.woff2" as="font" type="font/woff2" crossorigin>

  <style>
  /* BlackBeard font + page fade-in curtain */
  @font-face{
    font-family: "BlackBeard";
    src: url("./blackbeardregular-webfont.woff2") format("woff2"); /* adjust path if in /fonts */
    font-weight: 400;
    font-style: normal;
    font-display: swap;
  }

html{
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

html, body {
  height: 100%;
  margin: 0;
  background: transparent;
  overflow: hidden;          /* ← disables scrolling */
}

/* --- page fade-in curtain --- */
#curtain{
  position: fixed;
  inset: 0;
  background: #000;               /* start fully black */
  z-index: 2147483646;            /* just below #waitlistBox (…47) */
  opacity: 1;
  transition: opacity 2.5s ease;  /* 2.5s fade */
}

/* when ready, fade away (add .ready to <body> in JS) */
body.ready #curtain{
  opacity: 0;
  pointer-events: none;           /* stop blocking clicks after fade */
}

body {
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif;
  color: #fff;
  background: #000;
  overscroll-behavior: none;
  touch-action: manipulation;
  user-select: none;
  padding-bottom: max(20px, env(safe-area-inset-bottom));
}

/* Red backdrop */
.bg {
  position: fixed; inset: 0; z-index: -1;
  background-color: #7b0000;
  background-position: center; background-repeat: no-repeat; background-size: cover;
  background-image: url('RedBackdrop.webp?v=2');
}

/* Page layout */
.wrap { min-height: 100vh; display: grid; grid-template-rows: auto 1fr auto; gap: 8px; padding: 6px 8px; }
header { display: grid; place-items: center; }
main   { display: grid; place-items: center; }
footer {
  position: fixed;           /* fixed so we can place it precisely */
  left: 0;
  right: 0;
  top: 70vh;                 /* temporary; JS will set exact top */
  z-index: 10000;            /* above the hotzone (9999) */
  display: grid;
  place-items: center;
  gap: 4px;
  padding: 8px 8px max(12px, env(safe-area-inset-bottom));
}

/* logo controls */
.logo {
  width: min(54vw, 320px);   /* keep your current logical size */
  height: auto;
  display: block;
  margin: 0 auto 2px;
  pointer-events: none;
  -webkit-user-drag: none;

  /* visually enlarge without changing layout box, and push it lower */
  transform: scale(1.55) translateY(26px); /* adjust px value to taste */
  transform-origin: center;
  will-change: transform;
}

/* ↓ make stage a bit shorter so cards sit closer to both logo & footer */
.stage { position: relative; width: min(92vw, 480px); height: min(66vh, 560px);
         margin: 0 auto; display:grid; place-items:center; }

/* ===== progressive viewport units ===== */
@supports (height: 1svh) {
  .wrap  { min-height: 100svh; }
  .stage { height: min(66svh, 560px); }
}
@supports (height: 1dvh) {
  .wrap  { min-height: 100dvh; }
  .stage { height: min(66dvh, 560px); }
}
/* ===== end progressive units ===== */

.cardArea { position: absolute; inset: 0; }
/* Remove shared shadow so arms don't darken the body */
.card     { position:absolute; image-rendering:auto; filter: none; }
/* Keep arms clean (explicit) */
.arm      { filter: none; }

/* Body (center card) */
.centerCard { 
  cursor:pointer; 
  transition: transform 320ms ease-in, filter 300ms ease-in-out; 
  /* Give the shadow only to the body */
  filter: drop-shadow(0 6px 16px rgba(0,0,0,.45));
}
.centerCard.squish { transform-origin:center; transform: scaleX(0.02); }


/* yellow "ready" pulse (unchanged) */
@keyframes pulseGlow {
  0%   { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  50%  { filter: drop-shadow(0 0 22px rgba(255,234,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  100% { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
}
.clickable { animation: pulseGlow 1.4s ease-in-out infinite; }

/* red "can't click" pulse for champion */
@keyframes pulseNoClickRed {
  0%   { filter: drop-shadow(0 0 0 rgba(255,0,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  45%  { filter: drop-shadow(0 0 22px rgba(255,0,0,.95)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  100% { filter: drop-shadow(0 0 0 rgba(255,0,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
}
.cantClickPulse {
  animation: pulseNoClickRed 1.05s ease-in-out 0s 2; /* 2 quick red pulses */
}

/* Arms (slightly smoother final approach) */
:root { --arm-in-ms: 2800ms; --arm-out-ms: 1200ms; }

.arm {
  opacity: 0;
  pointer-events: none;

  /* keep the GPU engaged and allow sub-pixel interpolation */
  will-change: left, top, transform;
  transform: translateZ(0.001px);

  /* slightly less “sticky” ease-out at the end */
  transition-property: left, top, transform, opacity;
  transition-duration: var(--arm-in-ms), var(--arm-in-ms), var(--arm-in-ms), 450ms;
  transition-timing-function:
    cubic-bezier(.28,.95,.4,1),
    cubic-bezier(.28,.95,.4,1),
    cubic-bezier(.28,.95,.4,1),
    ease-out;
}



/* Champion perimeter frame — hidden per request */
.champFrame { display:none !important; }

/* ===== Champion congrats text ===== */
#champCongrats{
  position:fixed; inset:auto; left:50%; top:50%;
  transform: translate(-50%,-50%) scale(0.6);
  z-index:2147483645;
  font-family:"BlackBeard", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  font-weight: 700;                     /* bold */
  color:#800000;                        /* default maroon; JS will override per class if needed */
  -webkit-text-stroke: 2px #000;        /* black outline */
  text-shadow: 0 3px 10px rgba(0,0,0,.55);
  letter-spacing:.02em;
  white-space:nowrap;
  opacity:0;
  animation: champBalloon 1400ms ease-out forwards;
}
@keyframes champBalloon{
  0%   { opacity:0; transform:translate(-50%,-50%) scale(0.6); }
  60%  { opacity:1; transform:translate(-50%,-50%) scale(1.15); }
  100% { opacity:0; transform:translate(-50%,-50%) scale(1.0); }
}

/* ===== Confetti canvas overlay ===== */
#confettiCanvas{
  position:fixed; inset:0; z-index:2147483644;
  pointer-events:none; /* never block clicks */
}

/* ===== Hard-disable Champion interactivity/affordances after reveal ===== */
body.hasChampion #centerCard{
  cursor: default !important;
  pointer-events: none !important;
  animation: none !important;      /* kills yellow pulse etc. */
  filter: drop-shadow(0 6px 16px rgba(0,0,0,.45)); /* keep your shadow, no red pulse */
}


/* CTA text */
.cta { 
  font-family: "BlackBeard", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif;
  text-align: center;
  font-weight: 400;
  letter-spacing: .02em;
  text-shadow: 0 2px 8px rgba(0,0,0,.6);
  line-height: 0.9
;
  font-size: 1.5em;   /* ~50% bigger */
}

/* iOS-only size guard for CTA (A+B addition) */
@supports (-webkit-touch-callout: none) {
  .cta {
    font-size: clamp(18px, 4.2vw, 28px);
    line-height: 1.05;
  }
}

/* colored words */
.cta .blue { color: #4DA3FF; }     /* WAITLIST */
.cta .gold {
  color: #FFD166; 
  text-shadow:
    0 0 6px rgba(255, 209, 102, 0.8),
    0 0 12px rgba(255, 209, 102, 0.6),
    0 0 20px rgba(255, 209, 102, 0.5);
}    /* GOLDEN ATTENDANT */

/* default: stack to 3 lines on mobile */
.cta .line { display: block; }

/* desktop and wider: collapse to one row */
@media (min-width: 700px){
  .cta {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-wrap: nowrap;
    gap: .4ch;                     /* small spacing between segments */
  }
  .cta .line { display: inline; }
}

.copyright {
  text-align: center;
  font-size: 0.8rem;
  opacity: 0.75;
}

img { -webkit-user-drag: none; user-drag: none; }

/* ===== Visible overlay clickbox for testing ===== */
#waitlistBox{
  position: fixed;
  left: 0; right: 0;
  z-index: 2147483647;      /* sit above everything */
  display: block;
  pointer-events: auto;     /* make sure it can receive clicks */
  background: transparent !important;
  border: 0 !important;
  outline: none !important;
  text-decoration: none;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  touch-action: manipulation;

  /* TEMP while testing so you can see it; remove later */
  background: rgba(0,255,255,.18) !important;
  outline: 1px dashed #00ced1;
}

/* TEMP iOS test: disable the big overlay entirely */
/* #waitlistBox { display: none !important; } */


</style>
</head>

<body>
  <!-- Curtain must be first so it covers everything -->
  <div id="curtain" aria-hidden="true"></div>

  <!-- Single background -->
  <div class="bg" aria-hidden="true"></div>

  <!-- Single wrapper -->
  <div class="wrap">
    <header>
      <img class="logo" src="logo.webp" alt="Car World Colosseum" width="900" height="522" />
    </header>

    <main>
      <div class="stage" id="stage" role="region" aria-label="Game stage">
        <div class="cardArea" id="cardArea">
          <img id="centerCard" class="card centerCard" alt="Attendant" />
          <img id="armLeft"   class="card arm" alt="Left Arm" />
          <img id="armTop"    class="card arm" alt="Top Arm" />
          <img id="armRight"  class="card arm" alt="Right Arm" />
          <div id="champFrame" class="champFrame" aria-hidden="true"></div>
        </div>
      </div>
    </main>

    <!-- Visible overlay clickbox linking to the waitlist (for testing) -->
    <a id="waitlistBox"
       href="https://forms.gle/hJcNRWekxT2RLGMHA"
       target="_blank" rel="noopener"
       aria-label="Join the waiting list"></a>

    <footer>
      <div class="cta" role="text">
        <span class="line">JOIN THE <span class="blue">WAITLIST</span></span>
        <span class="line">FOR A CHANCE TO WIN</span>
        <span class="line">A <span class="gold">GOLDEN ATTENDANT</span></span>
      </div>
      <div class="copyright">© 2025 Car World Colosseum</div>
    </footer>
  </div>

<script>
/* =======================  DATA  ======================= */
const manifest = [
  'RedBackdrop.webp', 'logo.webp', 'body.webp', 'champion.webp',
  'fighter_left.webp','fighter_right.webp','fighter_sensitivity.webp',
  'fucker_left.webp','fucker_right.webp','fucker_sensitivity.webp',
  'fracker_left.webp','fracker_right.webp','fracker_sensitivity.webp',
  'freak_left.webp','freak_right.webp','freak_sensitivity.webp',
];
const CLASSES = ['fighter','fucker','fracker','freak'];

/* =======================  ELTS  ======================= */
const stage      = document.getElementById('stage');
const centerCard = document.getElementById('centerCard');
const armLeft    = document.getElementById('armLeft');
const armTop     = document.getElementById('armTop');
const armRight   = document.getElementById('armRight');
const champFrame = document.getElementById('champFrame');

/* =======================  HELPERS  ======================= */
const preload = (url) => new Promise(res => { const i = new Image(); i.onload = i.onerror = res; i.src = url; });
const prewarm = async () => { for (const u of manifest) await preload(u); };
const setSrc  = (img, file) => { img.src = file; };
const rc      = (arr) => arr[Math.floor(Math.random()*arr.length)];
/* ===== Champion FX: Colors, Confetti, Congrats Text, Lockout ===== */
const CHAMP_COLORS = {
  fighter: '#800000',   // Maroon
  fucker:  '#F0EAD6',   // Eggshell
  freak:   '#6A0DAD',   // Purple
  fracker: '#000000'    // Black
};

function showChampionCongrats(hex){
  const el = document.createElement('div');
  el.id = 'champCongrats';
  el.textContent = 'CONGRATULATIONS CHAMPION';
  el.style.color = hex;
  document.body.appendChild(el);
  el.addEventListener('animationend', () => el.remove(), { once:true });
}

function fireConfetti(hex){
  // minimal, self-cleaning canvas burst
  const cvs = document.createElement('canvas');
  cvs.id = 'confettiCanvas';
  const ctx = cvs.getContext('2d');
  document.body.appendChild(cvs);

  const DPR = Math.max(1, window.devicePixelRatio || 1);
  function resize(){
    cvs.width  = Math.floor(window.innerWidth  * DPR);
    cvs.height = Math.floor(window.innerHeight * DPR);
  }
  resize();

  // particles
  const N = 140;                       // small burst
  const cx = cvs.width  / 2;
  const cy = cvs.height / 2;
  const parts = Array.from({length:N}, () => {
    const a = Math.random() * Math.PI * 2;
    const sp = 4 + Math.random()*7;    // speed
    return {
      x: cx, y: cy,
      vx: Math.cos(a) * sp * DPR,
      vy: Math.sin(a) * sp * DPR - 2*DPR,
      w:  2*DPR + Math.random()*3*DPR,
      h:  6*DPR + Math.random()*10*DPR,
      r:  Math.random()*Math.PI,
      vr: (Math.random()-0.5)*0.3,
      alpha: 1
    };
  });

  const color = hex;
  const grav = 0.12 * DPR;
  const drag = 0.995;
  const lifeMs = 1300;
  const t0 = performance.now();

  function tick(t){
    const k = (t - t0) / lifeMs;
    ctx.clearRect(0,0,cvs.width,cvs.height);

    parts.forEach(p => {
      p.vx *= drag; p.vy = p.vy*drag + grav;
      p.x += p.vx;  p.y += p.vy;  p.r += p.vr;
      p.alpha = Math.max(0, 1 - k*k);
      ctx.save();
      ctx.globalAlpha = p.alpha;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.r);
      ctx.fillStyle = color;
      ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.restore();
    });

    if (t - t0 < lifeMs){
      requestAnimationFrame(tick);
    } else {
      cvs.remove();
    }
  }
  requestAnimationFrame(tick);
}

/* Call once when the Champion is confirmed */
function onChampionReveal(winnerClass){
  const hex = CHAMP_COLORS[winnerClass] || '#800000';
  document.body.classList.add('hasChampion');

  // kill any affordances/pulses immediately
  centerCard.classList.remove('clickable', 'cantClickPulse');
  centerCard.style.cursor = 'default';
  centerCard.style.pointerEvents = 'none';

  // FX
  fireConfetti(hex);
  showChampionCongrats(hex);
}

/* =======================  LAYOUT (3×2 T) — SCROLL-SAFE  ======================= */
let BODY_AR = 375/525; // default portrait ratio so we can place immediately
let layout  = null;    // {w,h, body, top, left, right, off, frame}
const PAD   = 6;

function computeLayout(){
  // Work in coordinates RELATIVE to the stage (no viewport left/top)
  const rW = stage.clientWidth;
  const rH = stage.clientHeight;

  const maxW   = (rW - PAD*2) / 3;
  const maxH   = (rH - PAD*2) / 2;
  const wFromH = maxH * BODY_AR;
  const cardW  = Math.min(maxW, wFromH);
  const cardH  = cardW / BODY_AR;

  const blockW = cardW * 3, blockH = cardH * 2;

  // bias upward inside the stage
  const freeY     = rH - blockH;
  const blockLeft = Math.round((rW - blockW)/2);
  const blockTop  = Math.round(freeY * 0.3);

  const col0 = blockLeft;
  const col1 = blockLeft + cardW;
  const col2 = blockLeft + cardW*2;
  const row0 = blockTop;
  const row1 = blockTop + cardH;

  layout = {
    w: cardW, h: cardH,
    body:  { left: col1, top: row1 }, // bottom-center
    top:   { left: col1, top: row0 },
    left:  { left: col0, top: row1 },
    right: { left: col2, top: row1 },
    off: {
      // Off-screen locations also relative to stage
      left:  { left: col0 - rW, top: row1 },
      top:   { left: col1,      top: row0 - rH },
      right: { left: col2 + rW, top: row1 },
    },
    frame: { left: blockLeft, top: blockTop, width: blockW, height: blockH },
  };
}

function place(el, rect){
  el.style.width  = layout.w + 'px';
  el.style.height = layout.h + 'px';
  el.style.left   = rect.left + 'px';
  el.style.top    = rect.top  + 'px';
}
function placeCenter(){ place(centerCard, layout.body); }

function positionHotzone(){
  const hz = document.getElementById('waitlistBox');
  if (!hz || !layout) return;

  const stageRect  = stage.getBoundingClientRect();
  const bodyBottom = stageRect.top + layout.body.top + layout.h;

  const topPx = Math.max(0, Math.round(bodyBottom + 1)); // 1px gap

  // ===== overlay guard patch (added) =====
  const minTop = Math.round(bodyBottom - layout.h * 0.2); // never jump above near-body area
  hz.style.top = Math.max(topPx, minTop) + 'px';
  // ===== end patch =====

  hz.style.bottom = '0';
  hz.style.left = '0';
  hz.style.right = '0';
  hz.style.display = 'block';
}

function positionFooter() {
  const footer = document.querySelector('footer');
  if (!footer || !layout) return;

  // measure footer height (ensure it’s rendered)
  footer.style.visibility = 'hidden';
  footer.style.top = '0px';
  footer.style.bottom = '';
  footer.style.display = 'grid';
  const footerH = footer.getBoundingClientRect().height || 0;
  footer.style.visibility = '';

  // body bottom in viewport coords: stage top + body top + card height
  const stageRect = stage.getBoundingClientRect();
  const bodyBottom = stageRect.top + layout.body.top + layout.h;

  // place footer 10px below the body, but keep it on-screen
  const gap = 10;
  let topPx = Math.round(bodyBottom + gap);

  // clamp: never let footer go off bottom edge
  const maxTop = Math.max(0, window.innerHeight - footerH);
  if (topPx > maxTop) topPx = maxTop;

  footer.style.top = topPx + 'px';
  footer.style.bottom = ''; // we’re anchoring by top
}

/* Keep layout correct on resize/scroll (and move the waitlist hotzone) */
function relayoutVisible(){
  computeLayout();
  placeCenter();

if (state === 'armsIn' || state === 'animIn') {
  place(armLeft, layout.left);
  place(armTop,  layout.top);
  place(armRight,layout.right);
} else {
  place(armLeft, layout.off.left);
  place(armTop,  layout.off.top);
  place(armRight,layout.off.right);
}


  positionHotzone();
  positionFooter();

}

window.addEventListener('resize', relayoutVisible);
window.addEventListener('scroll',  relayoutVisible, { passive: true });

/* =======================  STATE  ======================= */
let state = 'boot';          // 'idle', 'animIn', 'armsIn', 'armsOut'
let locked = false;          // champion lock
let busy   = false;          // click guard while animating
let pendingArms = null;      // holds the set used for the next "enter" action

/* =======================  INIT  ======================= */
async function init(){
  computeLayout(); placeCenter(); positionHotzone(); positionFooter();

// ensure first-run starts from the OFF boxes (before any click)
place(armLeft,  layout.off.left);
place(armTop,   layout.off.top);
place(armRight, layout.off.right);
armLeft.style.opacity = '0';
armTop.style.opacity  = '0';
armRight.style.opacity= '0';
// make sure we don't accidentally show a final-frame transform on first paint
armLeft.style.transform  = 'translate(0,0)';
armTop.style.transform   = 'translate(0,0)';
armRight.style.transform = 'translate(0,0)';


  centerCard.onload = () => {
    if (centerCard.naturalWidth) {
      BODY_AR = centerCard.naturalWidth / centerCard.naturalHeight;
      computeLayout(); placeCenter(); positionHotzone(); positionFooter();
    }
  };
  setSrc(centerCard, 'body.webp');

  await prewarm();                     // images/fonts warmed
  centerCard.classList.add('clickable');
  state = 'idle';

  // ↓ start the fade-out AFTER everything's ready
  requestAnimationFrame(() => {
    document.body.classList.add('ready');

    // remove the curtain after the fade completes
    const curtain = document.getElementById('curtain');
    if (curtain) {
      curtain.addEventListener('transitionend', () => curtain.remove(), { once: true });
      // fallback in case transitionend doesn't fire
      setTimeout(() => curtain && curtain.remove(), 2500);
    }
  });
}

init();

// AFTER init();
window.addEventListener('resize', () => {
  computeLayout();
  placeCenter();
  positionHotzone();
  positionFooter();

  if (state === 'armsIn' || state === 'animIn') {
    place(armLeft, layout.left);
    place(armTop,  layout.top);
    place(armRight, layout.right);
  } else {
    place(armLeft, layout.off.left);
    place(armTop,  layout.off.top);
    place(armRight, layout.off.right);
  }
});


/* =======================  GAME LOGIC  ======================= */
function pickArms(){
  const L = rc(CLASSES), T = rc(CLASSES), R = rc(CLASSES);
  return {
    left:  { cls:L, file: `${L}_left.webp` },
    top:   { cls:T, file: `${T}_sensitivity.webp` },
    right: { cls:R, file: `${R}_right.webp` },
  };
}
function isChampion(a){ return a.left.cls === a.top.cls && a.left.cls === a.right.cls; }

async function enterArms(arms){
  // set sources
  setSrc(armLeft,  arms.left.file);
  setSrc(armTop,   arms.top.file);
  setSrc(armRight, arms.right.file);

  // make sure images are paint-ready (first run can be racy)
  try {
    await Promise.allSettled([
      armLeft.decode ? armLeft.decode() : Promise.resolve(),
      armTop.decode ? armTop.decode()  : Promise.resolve(),
      armRight.decode ? armRight.decode() : Promise.resolve(),
    ]);
  } catch(_) {}

  // >>> ADD THIS LINE HERE <<<
  state = 'animIn';

  // compute deltas from OFF → TARGET
  const dLx = layout.off.left.left  - layout.left.left;
  const dLy = layout.off.left.top   - layout.left.top;
  const dTx = layout.off.top.left   - layout.top.left;
  const dTy = layout.off.top.top    - layout.top.top;
  const dRx = layout.off.right.left - layout.right.left;
  const dRy = layout.off.right.top  - layout.right.top;

  // (rest of the function unchanged…)

  // pin each arm at its final box so only transform animates
  place(armLeft,  layout.left);
  place(armTop,   layout.top);
  place(armRight, layout.right);

  // initial state (off-screen via translate, hidden)
  armLeft.style.opacity='0';  armTop.style.opacity='0';  armRight.style.opacity='0';
  armLeft.style.transform  = `translate(${dLx}px, ${dLy}px)`;
  armTop.style.transform   = `translate(${dTx}px, ${dTy}px)`;
  armRight.style.transform = `translate(${dRx}px, ${dRy}px)`;

  // force a style/paint, then schedule the final state on the next *next* frame
  // (double rAF avoids the first transition being coalesced on some desktops)
  void armLeft.offsetWidth; void armTop.offsetWidth; void armRight.offsetWidth;
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      armLeft.style.opacity='1';  armTop.style.opacity='1';  armRight.style.opacity='1';
      armLeft.style.transform='translate(0,0)';
      armTop.style.transform='translate(0,0)';
      armRight.style.transform='translate(0,0)';
    });
  });

  await new Promise(r => setTimeout(r, 2800 + 0)); // matches --arm-in-ms
  state = 'armsIn';
}


async function exitArms(){
  // compute deltas from TARGET → OFF (reverse of enter)
  const dLx = layout.off.left.left  - layout.left.left;
  const dLy = layout.off.left.top   - layout.left.top;
  const dTx = layout.off.top.left   - layout.top.left;
  const dTy = layout.off.top.top    - layout.top.top;
  const dRx = layout.off.right.left - layout.right.left;
  const dRy = layout.off.right.top  - layout.right.top;

  // ensure we’re starting at rest at the target box
  place(armLeft,  layout.left);
  place(armTop,   layout.top);
  place(armRight, layout.right);

  // animate out purely via transform (plus a touch of rotation like before)
  requestAnimationFrame(() => {
    armLeft.style.transform  = `translate(${dLx}px, ${dLy}px) rotate(-18deg)`;
    armTop.style.transform   = `translate(${dTx}px, ${dTy}px) rotate(-18deg)`;
    armRight.style.transform = `translate(${dRx}px, ${dRy}px) rotate(18deg)`;
    armLeft.style.opacity = '0';
    armTop.style.opacity  = '0';
    armRight.style.opacity= '0';
  });

  await new Promise(r => setTimeout(r, 1200 + 60)); // matches --arm-out-ms
  state = 'armsOut';

  // park them at the off boxes (keeps layout consistent if resized mid-fade)
  place(armLeft,  layout.off.left);
  place(armTop,   layout.off.top);
  place(armRight, layout.off.right);
}


/* =======================  INTERACTION  ======================= */
function pulseCantClick() {
  const els = [centerCard, armLeft, armTop, armRight];
  els.forEach(el => {
    // ensure we don't stack pulses
    el.classList.remove('cantClickPulse');
    // kick (reflow) so re-adding animation restarts it
    void el.offsetWidth;
    el.classList.add('cantClickPulse');
    el.addEventListener('animationend', function onA() {
      el.classList.remove('cantClickPulse');
      el.removeEventListener('animationend', onA);
    }, { once: true });
  });
}

centerCard.addEventListener('click', async () => {
  if (busy) return;

  // If champion is showing, clicks only produce a red "can't click" pulse.
  if (locked) {
    pulseCantClick();
    return;
  }

  busy = true;

  if (state === 'idle' || state === 'armsOut') {
    centerCard.classList.remove('clickable');
    if (!pendingArms) pendingArms = pickArms();
await enterArms(pendingArms);

if (isChampion(pendingArms)) {
  locked = true;
  centerCard.classList.remove('clickable', 'cantClickPulse');

  centerCard.classList.add('squish');
  centerCard.addEventListener('transitionend', function onT(e){
    if (e.propertyName !== 'transform') return;
    centerCard.removeEventListener('transitionend', onT);

    setSrc(centerCard, 'champion.webp');
    centerCard.style.transition = 'transform 380ms ease-out';
    centerCard.classList.remove('squish');

    const winnerClass = pendingArms.left.cls; // all three match
    onChampionReveal(winnerClass);
  }, { once:true });
} else {
  centerCard.classList.add('clickable');
  pendingArms = null;
}


  } else if (state === 'armsIn') {
    centerCard.classList.remove('clickable');
    await exitArms();
    centerCard.classList.add('clickable');
  }

  busy = false;
});

/* Deter saving from the stage/logo/bg */
document.addEventListener('contextmenu', (e) => {
  if (e.target.closest('.stage, .logo, .bg')) e.preventDefault();
});
</script>
</body>
</html>
