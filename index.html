<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Car World Colosseum</title>
<link rel="icon" href="/favicon.png" />

<style>
html, body {
  height: 100%;
  margin: 0;
  background: transparent;
  overflow: hidden;          /* ← disables scrolling */
}

body {
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif;
  color: #fff;
  background: #000;
  overscroll-behavior: none;
  touch-action: manipulation;
  user-select: none;
  padding-bottom: max(20px, env(safe-area-inset-bottom));
}

/* Red backdrop */
.bg {
  position: fixed; inset: 0; z-index: -1;
  background-color: #7b0000;
  background-position: center; background-repeat: no-repeat; background-size: cover;
  background-image: url('RedBackdrop.webp?v=2');
}

/* Page layout */
.wrap { min-height: 100svh; display: grid; grid-template-rows: auto 1fr auto; gap: 8px; padding: 6px 8px; }
header { display: grid; place-items: center; }
main   { display: grid; place-items: center; }

/* --- footer height reserved for layout --- */
:root { --footer-h: 0px; }

main { 
  /* keep content clear of fixed footer + a small gap */
  padding-bottom: calc(var(--footer-h) + 10px);
}

footer {
  position: fixed;     /* always visible at bottom */
  left: 0;
  right: 0;
  bottom: 0;           /* <-- anchor to bottom instead of computing top */
  z-index: 10000;      /* above the hotzone (9999) */
  display: grid;
  place-items: center;
  gap: 4px;
  padding: 8px 8px max(12px, env(safe-area-inset-bottom));
  background: transparent; /* keeps your visual design identical */
}

/* logo controls */
.logo {
  width: min(54vw, 320px);   /* keep your current logical size */
  height: auto;
  display: block;
  margin: 0 auto 2px;
  pointer-events: none;
  -webkit-user-drag: none;

  /* visually enlarge without changing layout box, and push it lower */
  transform: scale(1.55) translateY(26px); /* adjust px value to taste */
  transform-origin: center;
  will-change: transform;
}

/* ↓ make stage a bit shorter so cards sit closer to both logo & footer */
.stage { position: relative; width: min(92vw, 480px); height: min(66svh, 560px);
         margin: 0 auto; display:grid; place-items:center; }

.cardArea { position: absolute; inset: 0; }
.card     { position:absolute; image-rendering:auto; filter: drop-shadow(0 6px 16px rgba(0,0,0,.45)); }

/* Body (center card) */
.centerCard { cursor:pointer; transition: transform 320ms ease-in, filter 300ms ease-in-out; }
.centerCard.squish { transform-origin:center; transform: scaleX(0.02); }

/* yellow "ready" pulse (unchanged) */
@keyframes pulseGlow {
  0%   { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  50%  { filter: drop-shadow(0 0 22px rgba(255,234,0,.9)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  100% { filter: drop-shadow(0 0 0 rgba(255,234,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
}
.clickable { animation: pulseGlow 1.4s ease-in-out infinite; }

/* red "can't click" pulse for champion */
@keyframes pulseNoClickRed {
  0%   { filter: drop-shadow(0 0 0 rgba(255,0,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  45%  { filter: drop-shadow(0 0 22px rgba(255,0,0,.95)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
  100% { filter: drop-shadow(0 0 0 rgba(255,0,0,0)) drop-shadow(0 6px 16px rgba(0,0,0,.45)); }
}
.cantClickPulse {
  animation: pulseNoClickRed 1.05s ease-in-out 0s 2; /* 2 quick red pulses */
}

/* Arms (slow entrances/exits) */
:root { --arm-in-ms: 3000ms; --arm-out-ms: 1200ms; }
.arm {
  opacity:0; pointer-events:none;
  transition:
    left var(--arm-in-ms) cubic-bezier(.16,1,.3,1),
    top  var(--arm-in-ms) cubic-bezier(.16,1,.3,1),
    transform var(--arm-in-ms) cubic-bezier(.16,1,.3,1),
    opacity 500ms ease-out;
}

/* Champion perimeter frame — hidden per request */
.champFrame { display:none !important; }

.cta { text-align:center; font-weight:700; letter-spacing:.02em; text-shadow:0 2px 8px rgba(0,0,0,.6); }
.cta .small { opacity:.85; font-weight:600; }
.copyright {
  text-align: center;
  font-size: 0.8rem;
  opacity: 0.75;
}

img { -webkit-user-drag: none; user-drag: none; }

/* ===== Invisible overlay clickbox ===== */
#waitlistBox {
  position: fixed;
  z-index: 9999;
  display: block;
  background: transparent !important;
  border: 0 !important;
  outline: none !important;
  text-decoration: none;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  touch-action: manipulation;
/* TEST ONLY */
background: rgba(0,255,255,.12) !important; outline: 2px solid #000; 

}
#waitlistBox:focus,
#waitlistBox:active,
#waitlistBox:focus-visible {
  outline: none !important;
  box-shadow: none !important;
  background: transparent !important;
}
</style>

<body>
  <div class="bg" aria-hidden="true"></div>

  <div class="wrap">
    <header>
      <img class="logo" src="logo.webp" alt="Car World Colosseum" width="900" height="522" />
    </header>

    <main>
      <div class="stage" id="stage" role="region" aria-label="Game stage">
        <div class="cardArea" id="cardArea">
          <img id="centerCard" class="card centerCard" alt="Attendant" />
          <img id="armLeft"   class="card arm" alt="Left Arm" />
          <img id="armTop"    class="card arm" alt="Top Arm" />
          <img id="armRight"  class="card arm" alt="Right Arm" />
          <div id="champFrame" class="champFrame" aria-hidden="true"></div>
        </div>
      </div>
    </main>

    <!-- Overlay clickbox linking to the waitlist -->
    <a id="waitlistBox"
       href="https://forms.gle/hJcNRWekxT2RLGMHA"
       target="_blank" rel="noopener"
       aria-label="Join the waiting list"></a>

    <footer>
      <div class="cta">
        <div class="small">JOIN THE WAITING LIST</div>
        <div>FOR A CHANCE TO WIN A GOLDEN ATTENDANT</div>
      </div>
      <div class="copyright">© 2025 Car World Colosseum</div>
    </footer>
  </div>

<script>
/* =======================  DATA  ======================= */
const manifest = [
  'RedBackdrop.webp', 'logo.webp', 'body.webp', 'champion.webp',
  'fighter_left.webp','fighter_right.webp','fighter_sensitivity.webp',
  'fucker_left.webp','fucker_right.webp','fucker_sensitivity.webp',
  'fracker_left.webp','fracker_right.webp','fracker_sensitivity.webp',
  'freak_left.webp','freak_right.webp','freak_sensitivity.webp',
];
const CLASSES = ['fighter','fucker','fracker','freak'];

/* =======================  ELTS  ======================= */
const stage      = document.getElementById('stage');
const centerCard = document.getElementById('centerCard');
const armLeft    = document.getElementById('armLeft');
const armTop     = document.getElementById('armTop');
const armRight   = document.getElementById('armRight');
const champFrame = document.getElementById('champFrame');

/* =======================  HELPERS  ======================= */
const preload = (url) => new Promise(res => { const i = new Image(); i.onload = i.onerror = res; i.src = url; });
const prewarm = async () => { for (const u of manifest) await preload(u); };
const setSrc  = (img, file) => { img.src = file; };
const rc      = (arr) => arr[Math.floor(Math.random()*arr.length)];

/* --- footer helpers --- */
function getFooterHeight() {
  const f = document.querySelector('footer');
  return f ? (f.getBoundingClientRect().height || 0) : 0;
}
function updateFooterPadding() {
  const h = getFooterHeight();
  document.documentElement.style.setProperty('--footer-h', h + 'px');
}

/* =======================  LAYOUT ======================= */
let BODY_AR = 375/525;
let layout  = null;
const PAD   = 6;

function computeLayout(){
  const rW = stage.clientWidth;
  const rH = stage.clientHeight;
  const maxW   = (rW - PAD*2) / 3;
  const maxH   = (rH - PAD*2) / 2;
  const wFromH = maxH * BODY_AR;
  const cardW  = Math.min(maxW, wFromH);
  const cardH  = cardW / BODY_AR;
  const blockW = cardW * 3, blockH = cardH * 2;
  const freeY     = rH - blockH;
  const blockLeft = Math.round((rW - blockW)/2);
  const blockTop  = Math.round(freeY * 0.3);
  const col0 = blockLeft;
  const col1 = blockLeft + cardW;
  const col2 = blockLeft + cardW*2;
  const row0 = blockTop;
  const row1 = blockTop + cardH;

  layout = {
    w: cardW, h: cardH,
    body:  { left: col1, top: row1 },
    top:   { left: col1, top: row0 },
    left:  { left: col0, top: row1 },
    right: { left: col2, top: row1 },
    off: {
      left:  { left: col0 - rW, top: row1 },
      top:   { left: col1,      top: row0 - rH },
      right: { left: col2 + rW, top: row1 },
    },
    frame: { left: blockLeft, top: blockTop, width: blockW, height: blockH },
  };
}

function place(el, rect){
  el.style.width  = layout.w + 'px';
  el.style.height = layout.h + 'px';
  el.style.left   = rect.left + 'px';
  el.style.top    = rect.top  + 'px';
}
function placeCenter(){ place(centerCard, layout.body); }

function positionHotzone(){
  const hz = document.getElementById('waitlistBox');
  const footer = document.querySelector('footer');
  if (!hz || !layout || !footer) return;

  const footerRect = footer.getBoundingClientRect();
  const stageRect  = stage.getBoundingClientRect();

  // body bottom in viewport coords
  const bodyBottom = stageRect.top + layout.body.top + layout.h;
  const offset = 6;
  let topPx  = Math.max(0, Math.round(bodyBottom + offset));

  // space we reserve at the bottom = footer height (because footer is fixed)
  const bottomPx = Math.max(0, Math.min(window.innerHeight, window.innerHeight - footerRect.top));

  // ensure a minimum click height so it doesn't vanish on desktop
  const minHeight = 48;
  let avail = window.innerHeight - bottomPx - topPx;
  if (avail < minHeight) {
    // pull the top up to make room, but never above 0
    topPx = Math.max(0, window.innerHeight - bottomPx - minHeight);
    avail = window.innerHeight - bottomPx - topPx;
  }

  if (avail <= 0) {
    hz.style.display = 'none';
    return;
  }

  hz.style.display = 'block';
  hz.style.top = topPx + 'px';
  hz.style.left = '0';
  hz.style.right = '0';
  hz.style.bottom = Math.max(0, bottomPx) + 'px';
}


function relayoutVisible(){
  computeLayout();
  placeCenter();
  if (state === 'armsIn') {
    place(armLeft, layout.left);
    place(armTop,  layout.top);
    place(armRight,layout.right);
  } else {
    place(armLeft, layout.off.left);
    place(armTop,  layout.off.top);
    place(armRight,layout.off.right);
  }
  updateFooterPadding();
  positionHotzone();
}
window.addEventListener('resize', relayoutVisible);

/* =======================  STATE  ======================= */
let state = 'boot';
let locked = false;
let busy   = false;
let pendingArms = null;

/* =======================  INIT  ======================= */
async function init(){
  computeLayout(); placeCenter(); updateFooterPadding(); positionHotzone();
  centerCard.onload = () => {
    if (centerCard.naturalWidth) {
      BODY_AR = centerCard.naturalWidth / centerCard.naturalHeight;
      computeLayout(); placeCenter(); updateFooterPadding(); positionHotzone();
    }
  };
  setSrc(centerCard, 'body.webp');
  await prewarm();
  centerCard.classList.add('clickable');
  state = 'idle';
}
init();

/* =======================  GAME LOGIC  ======================= */
function pickArms(){
  const L = rc(CLASSES), T = rc(CLASSES), R = rc(CLASSES);
  return {
    left:  { cls:L, file: `${L}_left.webp` },
    top:   { cls:T, file: `${T}_sensitivity.webp` },
    right: { cls:R, file: `${R}_right.webp` },
  };
}
function isChampion(a){ return a.left.cls === a.top.cls && a.left.cls === a.right.cls; }

async function enterArms(arms){
  setSrc(armLeft,  arms.left.file);
  setSrc(armTop,   arms.top.file);
  setSrc(armRight, arms.right.file);
  place(armLeft,  layout.off.left);
  place(armTop,   layout.off.top);
  place(armRight, layout.off.right);
  requestAnimationFrame(() => {
    armLeft.style.opacity='1'; armTop.style.opacity='1'; armRight.style.opacity='1';
    armLeft.style.transform='rotate(0deg)'; armTop.style.transform='rotate(0deg)'; armRight.style.transform='rotate(0deg)';
    place(armLeft, layout.left); place(armTop, layout.top); place(armRight, layout.right);
  });
  await new Promise(r => setTimeout(r, 3000 + 60));
  state = 'armsIn';
}

async function exitArms(){
  requestAnimationFrame(() => {
    armLeft.style.transform='rotate(-18deg)'; armTop.style.transform='rotate(-18deg)'; armRight.style.transform='rotate(18deg)';
    place(armLeft, layout.off.left);
    place(armTop,  layout.off.top);
    place(armRight,layout.off.right);
    armLeft.style.opacity='0'; armTop.style.opacity='0'; armRight.style.opacity='0';
  });
  await new Promise(r => setTimeout(r, 1200 + 60));
  state = 'armsOut';
}

/* =======================  INTERACTION  ======================= */
function pulseCantClick() {
  const els = [centerCard, armLeft, armTop, armRight];
  els.forEach(el => {
    el.classList.remove('cantClickPulse');
    void el.offsetWidth;
    el.classList.add('cantClickPulse');
    el.addEventListener('animationend', function onA() {
      el.classList.remove('cantClickPulse');
      el.removeEventListener('animationend', onA);
    }, { once: true });
  });
}

centerCard.addEventListener('click', async () => {
  if (busy) return;
  if (locked) { pulseCantClick(); return; }
  busy = true;
  if (state === 'idle' || state === 'armsOut') {
    centerCard.classList.remove('clickable');
    if (!pendingArms) pendingArms = pickArms();
    await enterArms(pendingArms);
    if (isChampion(pendingArms)) {
      locked = true;
      centerCard.classList.remove('clickable');
      centerCard.classList.add('squish');
      centerCard.addEventListener('transitionend', function onT(e){
        if (e.propertyName !== 'transform') return;
        centerCard.removeEventListener('transitionend', onT);
        setSrc(centerCard, 'champion.webp');
        centerCard.style.transition = 'transform 380ms ease-out';
        centerCard.classList.remove('squish');
      }, { once:true });
    } else {
      centerCard.classList.add('clickable');
      pendingArms = null;
    }
  } else if (state === 'armsIn') {
    centerCard.classList.remove('clickable');
    await exitArms();
    centerCard.classList.add('clickable');
  }
  busy = false;
});

/* Deter saving from the stage/logo/bg */
document.addEventListener('contextmenu', (e) => {
  if (e.target.closest('.stage, .logo, .bg')) e.preventDefault();
});
</script>
</body>
</html>
